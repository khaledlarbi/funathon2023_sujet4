#¬†2Ô∏è‚É£ Faire des statistiques agr√©g√©es par cat√©gories

Cette partie permet de calculer en amont de l'application des
statistiques descriptives qui pourront √™tre utilis√©es
par celle-ci. 

Il est pr√©f√©rable de minimiser la quantit√© de calculs
faits √† la vol√©e dans le cadre d'une application. Sinon,
le risque est une latence emb√™tante pour l'utilisateur
voire un crash du serveur √† cause de besoins
de ressources trop importants.

Cette partie propose ainsi de cr√©er en avance deux
bases de donn√©es synth√©tisant certaines statistiques
descriptives:

- Pour les variables nutritionnelles (calories, glucides, etc.), les
d√©ciles de la distribution. Ils permettront de placer notre produit
par rapport √† des produits similaires (ceux partageant la m√™me variable
de cat√©gorie, cr√©√©e pr√©c√©demment). 
- Pour les notes synth√©tiques (nutriscore, score nova et √©coscore), le
nombre de produits dans une cat√©gorie donn√©e (par exemple les
fromages √† pate crue) qui ont la m√™me note.

## 2.1. Pr√©liminaire (üü°,üü¢,üîµ,üî¥,‚ö´)


Sur le plan technique, cette partie propose deux cadres de manipulation
de donn√©es diff√©rents,
selon le balisage de la voie:

- üü°,üü¢,üîµ: utilisation de `Pandas`
- üî¥,‚ö´: requ√™tes SQL directement sur le fichier `Parquet` gr√¢ce √† `DuckDB`


Cette partie va fonctionner en trois temps:

1. Lecture des donn√©es `OpenFoodFacts` pr√©c√©demment produites
2. Construction de statistiques descriptives standardis√©es
3. Construction de graphiques √† partir de ces statistiques descriptives

Les √©tapes 1 et 2 sont s√©par√©es conceptuellement pour les parcours üü°,üü¢,üîµ. 
Pour les parcours üî¥ et ‚ö´, l'utilisation de requ√™tes SQL fait que ces
deux √©tapes conceptuelles sont intriqu√©es. Les parcours üü°,üü¢,üîµ
peuvent observer les morceaux de code propos√©s dans le cadre üî¥ et ‚ö´,
c'est assez instructif. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-warning" role="alert" style="color: rgba(0,0,0,.8); background-color: white; margin-top: 1em; margin-bottom: 1em; margin:1.5625emauto; padding:0 .6rem .8rem!important;overflow:hidden; page-break-inside:avoid; border-radius:.25rem; box-shadow:0 .2rem .5rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1); transition:color .25s,background-color .25s,border-color .25s ; border-right: 1px solid #dee2e6 ; border-top: 1px solid #dee2e6 ; border-bottom: 1px solid #dee2e6 ; border-left:.2rem solid #ffc10780;">
<h3 class="alert-heading"><i class="fa fa-lightbulb-o"></i> Hint</h3>
```

Cette partie peut √™tre faite sans avoir suivie la pr√©c√©dente. 
Il est alors recommand√© d'effectuer deux actions:

1. Dans le fichier `config.yaml`, remplacer `"projet-funathon"` par votre nom
d'utilisateur sur le `SSP Cloud`
2. Cr√©er une cellule en copiant-collant le texte suivant et
en remplacant `<USERNAME_SSPCLOUD>` par votre nom d'utilisateur sur le SSPCloud. 

```python
# cr√©er une cellule de code et copier dedans ce texte
# remplacer `<USERNAME_SSPCLOUD>` par votre nom d'utilisateur sur le SSPCloud
!mc cp s3/projet-funathon/2023/sujet4/diffusion/openfood.parquet s3/<USERNAME_SSPCLOUD>/2023/sujet4/diffusion/openfood.parquet
```

Cette commande permet de copier le fichier d'exemple que nous avons
mis √† disposition vers votre espace personnel.

```{=html}
</div>
```
:::


Nous proposons d'importer √† nouveau nos configurations:

```{python}
from utils.import_yaml import import_yaml
config = import_yaml("config.yaml")
```

Les colonnes suivantes nous seront utiles dans cette partie:

```{python}
info_nutritionnelles = [
    'energy-kcal_100g', 'fat_100g', 'saturated-fat_100g',
    'carbohydrates_100g', 'sugars_100g',
    'proteins_100g', 'salt_100g']
indices_synthetiques = [
    "nutriscore_grade", "ecoscore_grade", "nova_group"
]
principales_infos = ['product_name', 'code', 'preprocessed_labels', 'coicop']
```

Voici, √† nouveau, la configuration pour permettre √† `Python`
de communiquer avec l'espace de stockage distant:

```{python}
import s3fs

config = import_yaml("config.yaml")
INPUT_OPENFOOD = f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/openfood.parquet"

# Initialisation de la connexion
fs = s3fs.S3FileSystem(
    client_kwargs={"endpoint_url": config["ENDPOINT_S3"]}
)
```


## 2.2. Import des donn√©es depuis l'espace de stockage distant avec `Pandas` (üü°,üü¢,üîµ)

Il est recommand√© pour les parcours üü°,üü¢,üîµ de travailler avec `Pandas` pour construire
des statistiques descriptives. Cela se fera en deux √©tapes:

- Import des donn√©es directement depuis l'espace de stockage, sans √©criture interm√©diaire sur le disque local,
puis nettoyage de celles-ci ;
- Construction de fonctions standardis√©es pour la production de statistiques descriptives.

### Import et nettoyage des donn√©es `OpenFoodFacts` (üü°, üü¢ et üîµ)

Il est possible de lire un CSV de plusieurs mani√®res avec `Python`.
L'une d'elle se fait √† travers le _[context manager](https://book.pythontips.com/en/latest/context_managers.html#context-managers)_. 
Le module `s3fs` permet d'utiliser ce _context manager_ pour lire un fichier distant, 
de mani√®re tr√®s similaire √† la lecture d'un fichier local. 

::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Lire les donn√©es depuis un espace distant (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

A partir du _context manager_ int√©gr√© √† `s3fs`, lire
les donn√©es en suivant les consignes suivantes:

- la localisation des donn√©es est stock√©e dans la variable `INPUT_OPENFOOD`
- Utiliser l'option `columns = principales_infos + info_nutritionnelles + indices_synthetiques`
pour n'importer que les variables n√©cessaires.

```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::


::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "Lire les donn√©es depuis un espace distant (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Lors de l'√©criture du fichier nous avons utilis√© la commande suivante:

```python
# Ecriture au format parquet sur l'espace de stockage distant
with fs.open(DESTINATION_OPENFOOD, "wb") as file_location:
    openfood.to_parquet(file_location)
```

Nous proposons de suivre la m√™me logique en changeant quelques √©l√©ments:

- La variable de chemin √† utiliser ici est `INPUT_OPENFOOD` ;
- Le contexte n'est plus √† l'√©criture (_"wb"_) mais √† la lecture (_"rb"_) ;
- La commande √† ex√©cuter dans ce contexte n'est plus l'√©criture d'un fichier parquet
mais `pd.read_parquet`. Utiliser
l'option `columns = principales_infos + info_nutritionnelles + indices_synthetiques`
pour n'importer que les variables n√©cessaires.

```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::


```{python}
#| classes: yellow-code
#| label: get-openfood-parquet
#| output: false

# Solution pour voie üü°, üü¢ et üîµ
import pandas as pd

# methode 1: pandas
with fs.open(INPUT_OPENFOOD, "rb") as remote_file:
    openfood = pd.read_parquet(
        remote_file,
        columns = principales_infos + \
        info_nutritionnelles + indices_synthetiques
    )
```

Les donn√©es ont ainsi l'aspect suivant:

```{python}
openfood.head(2)
```

### Statistiques descriptives (üü°, üü¢ et üîµ)

On va produire deux types de statistiques, pour afficher des graphiques permettant
de placer le produit dans la distribution de produits similaires:

- Distribution pour chaque nutriment d'int√©r√™t (calorie, gras, sucre...) des d√©ciles
- Distribution pour chaque score de qualit√© (nutriscore, score nova et √©coscore) des notes

Vous pouvez observer plus bas un exemple. Ici, on va construire une fois pour toute les
statistiques descriptives. Cela permettra de r√©duire les calculs faits par notre application au minimum.

```{python}
data_infos_nutritionnelles = openfood.loc[:,info_nutritionnelles + ["coicop"]]
```


::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Distribution des nutriments par cat√©gorie de produit (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er le dataframe `stats_nutritionnelles` de la mani√®re suivante:

1. A partir de `data_infos_nutritionnelles`, regrouper par _"coicop"_ et calculer les quantiles 0.1 ... 0.9
2. Utiliser `reset_index` pour renommer les variables de groupe `coicop` et `quantile`
3. Transformer la variable quantile pour avoir des valeurs entre 1 et 10 plut√¥t qu'entre 0.1 et 0.9
4. Les donn√©es sont au format _wide_ ce qui n'est pas tr√®s pratique. On pr√©f√®re en g√©n√©ral utiliser le format _long_. Utiliser
la fonction adapt√©e pour transformer de _wide_ -> _long_ sur les axes 'coicop' et 'quantile'


```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "Distribution des nutriments par cat√©gorie de produit (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er le dataframe `stats_nutritionnelles` de la mani√®re suivante:

1. A partir de `data_infos_nutritionnelles`, regrouper par _"coicop"_ et calculer les quantiles 0.1 ... 0.9
gr√¢ce √† la liste `[i/10 for i in range(1,10)]`
2. Utiliser `reset_index(names=['coicop', 'quantile'])` pour renommer les variables de groupe 


```{=html}
<details>
<summary>R√©ponse en cas de difficult√©</summary>
```

```python
stats_nutritionnelles = data_infos_nutritionnelles.groupby("coicop").quantile([i/10 for i in range(1,10)]).reset_index(names=['coicop', 'quantile'])
```

```{=html}
</details>
```

3. Utiliser la m√©thode `mul` pour avoir des quantiles entre 1 et 10 plut√¥t qu'entre 0.1 et 0.9
4. Les donn√©es sont au format _wide_ ce qui n'est pas tr√®s pratique. On pr√©f√®re en g√©n√©ral utiliser le format _long_. Utiliser
`pd.melt` pour pivoter les donn√©es sur les axes 'coicop' et 'quantile'


```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::

Pour obtenir un code modulaire, ce qui pr√©sente notamment
l'avantage d'√™tre plus lisible, nous avons cr√©√© une fonction
qui est pr√©sente dans le fichier `utils/stats_openfood.py`
dont le code est le suivant:

```{python}
#| classes: yellow-code
#| label: fonction-stats-nutriments
#| output: false

# Solution pour voie üü°, üü¢ et üîµ
def compute_stats_nutriments(data):
    stats_nutritionnelles = (
        data
        .groupby("coicop")
        .quantile([i/10 for i in range(1,10)])
        .reset_index(names=['coicop', 'quantile'])
    )
    stats_nutritionnelles['quantile'] = stats_nutritionnelles['quantile'].mul(10).astype(int)
    stats_nutritionnelles = pd.melt(stats_nutritionnelles, id_vars=['coicop', 'quantile'])
    return stats_nutritionnelles
```

Celle-ci d√©compose, pour chaque classe de produit,
la distribution des nutriments en dix classes. Les donn√©es sont ensuite
restructur√©es en format _long_ (plus pratique pour l'analyse ult√©rieure) 
gr√¢ce √† `pd.melt`.

Cette fonction peut √™tre utilis√©e de la mani√®re suivante:

```{python}
from utils.stats_openfood import compute_stats_nutriments
stats_nutritionnelles = compute_stats_nutriments(data_infos_nutritionnelles)
```

Nous proposons d'adopter la m√™me logique pour les notes mais au lieu de faire
des quantiles, on va simplement d√©nombrer le nombre d'observations qui ont
cette note dans une classe de produits. 

Nous allons utiliser le `DataFrame` suivant pour les calculs de notes:

```{python}
openfood_notes = openfood.loc[:,["coicop"] + indices_synthetiques]
```

::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "Distribution des notes par cat√©gorie de produit (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. Apr√®s un `groupby("coicop")`, effectuer un d√©compte des notes (`value_counts` en `Pandas`)
pour chaque variable de la liste `indices_synthetiques` gr√¢ce √† la m√©thode `agg`
puis renommer les deux variables d'index 'coicop' et 'note' gr√¢ce √† la m√©thode `reset_index`

```{=html}
<details>
<summary>R√©ponse en cas de difficult√©</summary>
```

```python
stats_notes = (
    openfood_notes
    .groupby("coicop")
    .agg({i:'value_counts' for i in indices_synthetiques})
    .reset_index(names=['coicop', 'note'])
)
```

```{=html}
</details>

```

2. Utiliser `pd.melt` pour pivoter les donn√©es vers un format _long_
via les axes `coicop` et `note`

3. Convertir la colonne `value` obtenue au format `Int64` (qui permet d'avoir
des valeurs manquantes)

4. D√©dupliquer les donn√©es en ne gardant que les paires uniques sur les variables
`variable, note, coicop` gr√¢ce √† la m√©thode `drop_duplicates`

5. Retirer les observations pour lesquelles la variable `note` est √©gale
√† `unknown`  ou `not-applicable`

6. Pour avoir les notes de toutes les variables sous forme de lettre, utiliser
le code suivant:

```python
stats_notes.loc[stats_notes['variable'] == "nova_group", "note"] = (
    stats_notes.loc[stats_notes['variable'] == "nova_group", "note"]
    .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
)
```

7. Utiliser la m√©thode `str.upper` puis convertir en string avec `astype(str)` 
pour avoir une variable de notes harmonis√©es


```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::

::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Distribution des notes par cat√©gorie de produit (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. Pour chaque valeur de la variable `coicop`,
avec la m√©thode `agg`, effectuer un d√©compte des notes (`value_counts` en `Pandas`)
pour chaque variable de la liste `indices_synthetiques` gr√¢ce √† la m√©thode `agg`.
Renommer ensuite les deux variables d'index 'coicop' et 'note' gr√¢ce √† la m√©thode `reset_index`

2. Pivoter les donn√©es vers un format _long_
via les axes `coicop` et `note`

3. Convertir la colonne `value` obtenue au format `Int64` (qui permet d'avoir
des valeurs manquantes)

4. D√©dupliquer les donn√©es en ne gardant que les paires uniques sur les variables
`variable, note, coicop`

5. Retirer les observations pour lesquelles la variable `note` est √©gale
√† `unknown`  ou `not-applicable`

6. Pour avoir les notes de toutes les variables sous forme de lettre, utiliser
le code suivant:

```python
stats_notes.loc[stats_notes['variable'] == "nova_group", "note"] = (
    stats_notes.loc[stats_notes['variable'] == "nova_group", "note"]
    .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
)
```

7. Passer toutes les notes en majuscules puis convertir en string avec `astype(str)` 


```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::


```{python}
# Solution pour voie üü°, üü¢ et üîµ
def compute_stats_grades(data, indices_synthetiques):
    stats_notes = (
        data
        .groupby("coicop")
        .agg({i:'value_counts' for i in indices_synthetiques})
        .reset_index(names=['coicop', 'note'])
    )
    stats_notes = pd.melt(stats_notes, id_vars = ['coicop','note'])
    stats_notes['note'] = stats_notes['note'].astype(str)
    stats_notes['value'] = stats_notes['value'].astype("Int64")
    stats_notes = stats_notes.dropna().drop_duplicates(subset = ['variable','note','coicop'])
    stats_notes = stats_notes.loc[~stats_notes['note'].isin(['unknown','not-applicable'])]
    stats_notes.loc[stats_notes['variable'] == "nova_group", "note"] = (
            stats_notes.loc[stats_notes['variable'] == "nova_group", "note"]
            .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
        )
    stats_notes['note'] =  stats_notes['note'].str.upper()
    stats_notes['note'] = stats_notes['note'].astype(str)
  
    return stats_notes

stats_notes = compute_stats_grades(openfood_notes, indices_synthetiques)
```

## 2.3. Import des donn√©es avec `DuckDB` (üî¥ et ‚ö´)

### Import des donn√©es `OpenFoodFacts` (üî¥ et ‚ö´)

Cette partie propose pour les parcours üî¥ et ‚ö´ de reproduire l'analyse faite par
les parcours üü°,üü¢ et üîµ via `Pandas`. 

`DuckDB` va √™tre utilis√© pour lire et agr√©ger les donn√©es. 
Pour lire directement depuis un syst√®me de stockage distant, sans pr√©-t√©l√©charger les 
donn√©es, vous pouvez utiliser la configuration suivante de `DuckDB`:

```{python}
import duckdb
con = duckdb.connect(database=':memory:')
con.execute("""
    INSTALL httpfs;
    LOAD httpfs;
    SET s3_endpoint='minio.lab.sspcloud.fr'
""")
```

Et voici un exemple minimal de lecture de donn√©es √† partir du chemin
`INPUT_OPENFOOD` d√©fini pr√©c√©demment. 

```{python}
duckdb_data = con.sql(
    f"SELECT product_name, preprocessed_labels, coicop, energy_100g FROM read_parquet('s3://{INPUT_OPENFOOD}') LIMIT 10"
)
duckdb_data.df() #conversion en pandas dataframe
```

### Statistiques descriptives (üî¥ et ‚ö´)

Nous proposons de fonctionner en deux temps:

- Cr√©er une requ√™te SQL qui, pour chaque classe de produit (notre variable de COICOP),
calcule les d√©ciles de la distribution de chaque variable directement depuis une clause
`SELECT`. Cette requ√™te √©tant assez difficile, elle est donn√©e directement pour le 
parcours üî¥ (mais pas de cadeau pour le parcours ‚ö´).
- Les donn√©es √† l'issue de cette √©tape √©tant sous une forme _wide_, ce qui est peu pratique,
nous proposons de les pivoter pour avoir un format _long_ (comme pour le parcours üü°,üü¢ etüîµ)

::: {.cell .markdown}
<!----- boite ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "‚ö´", title = "Distribution des nutriments par cat√©gorie de produit (‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction `quantile_one_variable_sql`
prenant un argument nomm√© `con` (connexion DuckDB) et un 
argument `variable` (par d√©faut √©gal √† `energy-kcal_100g`)
effectuant les op√©rations suivantes:

- Cr√©er un `DataFrame` `Pandas` apr√®s avoir agr√©g√© les donn√©es via `DuckDB`
en calculant les d√©ciles de la distribution de variable pour chaque cat√©gorie pour
une caract√©ristique nutritionnelle donn√©e

- Pivoter les donn√©es vers un format _long_ autour de l'axe `coicop` avec `Pandas`. Nommer la variable obtenue `quantile`

- Retirer le pr√©fixe `quantile` √† la colonne obtenue

- Cr√©er le `DataFrame` qui combine toutes ces statistiques de la mani√®re suivante:

```python
stats_nutritionnelles_sql = [quantile_one_variable_sql(con, nutriment) for nutriment in info_nutritionnelles]
stats_nutritionnelles_sql = pd.concat(stats_nutritionnelles_sql)
stats_nutritionnelles_sql.head(2)
```

```{=html}
</details>
</div>
```

<!----- end ‚ö´ ----->
:::

::: {.cell .markdown}
<!----- boite üî¥ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üî¥", title = "Distribution des nutriments par cat√©gorie de produit (üî¥)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction `quantile_one_variable_sql`
prenant un argument nomm√© `con` (connexion DuckDB) et un 
argument `variable` (par d√©faut √©gal √† `energy-kcal_100g`)
effectuant les op√©rations suivantes:

- Cr√©er un `DataFrame` `Pandas` apr√®s avoir agr√©g√© les donn√©es via `DuckDB` gr√¢ce
au mod√®le de requ√™te

```python
SELECT coicop, " + ", ".join(
        [f"PERCENTILE_CONT({q/10}) WITHIN GROUP (ORDER BY \"{variable}\") AS quantile{q}" for q in range(1,10)]
    ) + f" FROM read_parquet('s3://{INPUT_OPENFOOD}') GROUP BY coicop"
```

- Pivoter les donn√©es vers un format _long_ autour de l'axe `coicop` avec `Pandas`. Nommer la variable obtenue `quantile`

- Retirer le pr√©fixe `quantile` √† la colonne obtenue

- Cr√©er le `DataFrame` qui combine toutes ces statistiques de la mani√®re suivante:

```python
stats_nutritionnelles_sql = [quantile_one_variable_sql(con, nutriment) for nutriment in info_nutritionnelles]
stats_nutritionnelles_sql = pd.concat(stats_nutritionnelles_sql)
stats_nutritionnelles_sql.head(2)
```

```{=html}
</details>
</div>
```

<!----- end üî¥ ----->
:::

```{python}
def quantile_one_variable_sql(con, variable="energy-kcal_100g", path_within_s3 = "temp.parquet"):
    query = "SELECT coicop, " + ", ".join(
        [f"PERCENTILE_CONT({q/10}) WITHIN GROUP (ORDER BY \"{variable}\") AS quantile{q}" for q in range(1,10)]
    ) + f" FROM read_parquet('s3://{path_within_s3}') GROUP BY coicop"
    quantile_one_variable = pd.melt(con.sql(query).df(), id_vars="coicop", var_name="quantile")
    quantile_one_variable['quantile'] = quantile_one_variable['quantile'].str.replace("quantile","").astype(int)
    quantile_one_variable['variable'] = variable
    return quantile_one_variable
```

```{python}
stats_nutritionnelles_sql = [quantile_one_variable_sql(con, nutriment, INPUT_OPENFOOD) for nutriment in info_nutritionnelles]
stats_nutritionnelles_sql = pd.concat(stats_nutritionnelles_sql)
stats_nutritionnelles_sql.head(2)
```

Pour les notes, la logique est la m√™me :

::: {.cell .markdown}
<!----- boite ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "‚ö´", title = "Distribution des notes par cat√©gorie de produit (‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction `count_one_variable_sql` prenant un argument nomm√© `con` (connexion DuckDB) et un 
argument `variable` (par d√©faut √©gal √† `nova_group`)
effectuant les op√©rations suivantes:

- Cr√©er un `DataFrame` `Pandas` apr√®s avoir agr√©g√© les donn√©es via `DuckDB` gr√¢ce
√† une requ√™te qui, pour chaque coicop et type de note (cf. argument `variable`)
compte le nombre d'observations. 

- Cr√©e une variable `variable` √©gale √† la valeur de l'argument `variable`

- Nettoie la variable `note` selon le mod√®le suivant:

```python
stats_one_variable['note'] = stats_one_variable['note'].astype(str)
stats_one_variable = stats_one_variable.dropna().drop_duplicates(subset = ['variable','note','coicop'])
stats_one_variable = stats_one_variable.loc[~stats_one_variable['note'].isin(['unknown','not-applicable'])]
stats_one_variable.loc[stats_one_variable['variable'] == "nova_group", "note"] = (
            stats_one_variable.loc[stats_one_variable['variable'] == "nova_group", "note"]
            .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
        )
stats_one_variable['note'] =  stats_one_variable['note'].str.upper()
```

- Cr√©er le `DataFrame` qui combine toutes ces statistiques de la mani√®re suivante
en bouclant sur la liste `["nutriscore_grade", "ecoscore_grade", "nova_group"]`

```{=html}
</details>
</div>
```

<!----- end ‚ö´ ----->
:::


::: {.cell .markdown}
<!----- boite üî¥ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üî¥", title = "Distribution des notes par cat√©gorie de produit (üî¥)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction `count_one_variable_sql` prenant un argument nomm√© `con` (connexion DuckDB) et un 
argument `variable` (par d√©faut √©gal √† `nutriscore_grade`)
effectuant les op√©rations suivantes:

- Cr√©er un `DataFrame` `Pandas` apr√®s avoir agr√©g√© les donn√©es via `DuckDB` gr√¢ce
au mod√®le de requ√™te

```python
f"SELECT coicop, {variable} AS note, COUNT({variable}) AS value FROM read_parquet('s3://{path_within_s3}') GROUP BY coicop, {variable}"
```

- Cr√©e une variable `variable` √©gale √† la valeur de l'argument `variable`

- Nettoie la variable `note` selon le mod√®le suivant:

```python
stats_one_variable['note'] = stats_one_variable['note'].astype(str)
stats_one_variable = stats_one_variable.dropna().drop_duplicates(subset = ['variable','note','coicop'])
stats_one_variable = stats_one_variable.loc[~stats_one_variable['note'].isin(['unknown','not-applicable'])]
stats_one_variable.loc[stats_one_variable['variable'] == "nova_group", "note"] = (
            stats_one_variable.loc[stats_one_variable['variable'] == "nova_group", "note"]
            .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
        )
stats_one_variable['note'] =  stats_one_variable['note'].str.upper()

```

- Cr√©er le `DataFrame` qui combine toutes ces statistiques de la mani√®re suivante:

```python
grades = ["nutriscore_grade", "ecoscore_grade", "nova_group"]
stats_notes_sql = [count_one_variable_sql(con, note, INPUT_OPENFOOD) for note in grades]
stats_notes_sql = pd.concat(stats_notes_sql)
```

```{=html}
</details>
</div>
```

<!----- end üî¥ ----->
:::

```{python}
def count_one_variable_sql(con, variable, path_within_s3 = "temp.parquet"):
    query = f"SELECT coicop, {variable} AS note, COUNT({variable}) AS value FROM read_parquet('s3://{path_within_s3}') GROUP BY coicop, {variable}"
    stats_one_variable = con.sql(query).df().dropna()
    stats_one_variable['variable'] = variable
    stats_one_variable['note'] = stats_one_variable['note'].astype(str)
    stats_one_variable = stats_one_variable.dropna().drop_duplicates(subset = ['variable','note','coicop'])
    stats_one_variable = stats_one_variable.loc[~stats_one_variable['note'].isin(['unknown','not-applicable'])]
    stats_one_variable.loc[stats_one_variable['variable'] == "nova_group", "note"] = (
            stats_one_variable.loc[stats_one_variable['variable'] == "nova_group", "note"]
            .astype(float).astype("int64", errors = "ignore").apply(lambda d: chr(d + 64))
        )
    stats_one_variable['note'] =  stats_one_variable['note'].str.upper()
    stats_one_variable['note'] = stats_one_variable['note'].astype(str)


    return stats_one_variable
```

```{python}
grades = ["nutriscore_grade", "ecoscore_grade", "nova_group"]
stats_notes_sql = [count_one_variable_sql(con, note, INPUT_OPENFOOD) for note in grades]
stats_notes_sql = pd.concat(stats_notes_sql)
```




### Sauvegarde dans l'espace de stockage distant


```python
def write_stats_to_s3(data, destination):
    # Ecriture au format parquet sur l'espace de stockage distant
    with fs.open(destination, "wb") as file_location:
        data.to_parquet(file_location)

write_stats_to_s3(stats_nutritionnelles, f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/stats_nutritionnelles_pandas.parquet")
write_stats_to_s3(stats_notes, f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/stats_notes_pandas.parquet")
write_stats_to_s3(stats_nutritionnelles_sql, f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/stats_nutritionnelles_sql.parquet")
write_stats_to_s3(stats_notes_sql, f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/stats_notes_sql.parquet")
```



### Cr√©ation d'un mod√®le de graphiques (üü°,üü¢,üîµ,üî¥,‚ö´)

On va utiliser `Plotly` pour cr√©er des graphiques et, ult√©rieurement,
les afficher sur notre page web. Cela permettra d'avoir un peu de
r√©activit√©.

::: {.cell .markdown}
<!----- boite ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "‚ö´", title = "Mod√®le de figure pour les qualit√©s nutritionnelles (‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction standardis√©e qui pr√©sente, sous forme de diagramme en barre,
les valeurs nutritionnelles dans une classe de produit donn√©e (identifi√©e par la COICOP)
de chaque d√©cile.

```{=html}
</details>
</div>
```

<!----- end ‚ö´ ----->
:::


::: {.cell .markdown}
<!----- boite üî¥ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üî¥", title = "Mod√®le de figure pour les qualit√©s nutritionnelles (üî¥)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction standardis√©e dont les arguments sont

- Un jeu de donn√©es nomm√© `data`
- Une caract√©ristique nutritionnelle nomm√©e `variable_nutritionnelle` par d√©faut √©gale √† `energy-kcal_100g`
- Une cat√©gorie nomm√©e `coicop`, par d√©faut √©gale √† `01.1.7.3.2`
- Un d√©cile d'appartenance nomm√© `valeur_produit` par d√©faut √©gal √† 8 

Cette fonction effectue les t√¢ches suivantes:

- Ne conserver, dans notre ensemble de valeurs agr√©g√©es, que celles relatives √† la COICOP et
√† la caract√©ristique nutritionnelle qu'on recherche ;
- Repr√©senter sous forme de diagramme en barre les valeurs nutritionnelles pour chaque d√©cile de la 
distribution avec, en rouge, celle de notre produit (`valeur_produit`)

```{=html}
</details>
</div>
```

<!----- end üî¥ ----->
:::

::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Mod√®le de figure pour les qualit√©s nutritionnelles (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Pour pr√©parer cet exercice, cr√©er les objets suivants:

```python
data = stats_nutritionnelles.copy()
variable_nutritionnelle = 'energy-kcal_100g'
coicop = "01.1.7.3.2"
valeur_produit = 8
```

1. Ne conserver que les observations o√π `data['variable']` est √©gale √† la valeur `variable_nutritionnelle`
et o√π la variable `coicop` est √©gale √† la valeur `coicop`. A l'issue de ces
filtres, nommer le dataframe obtenu `example_coicop`
2. Cr√©er une 
colonne stockant les couleurs de notre graphique. On utilisera le rouge (_red_) lorsque la variable quantile
est √©gale √† `valeur_produit` et du bleu (_royalblue_) sinon. Nommer cette variable `color`.
3. Cr√©er un diagramme en barre avec:
        + sur l'axe des _x_ les quantiles
        + sur l'axe des _y_, la valeur √† repr√©senter
        + la couleur √† partir de la variable `color`
        + Les _labels_ : pour l'axe des _x_ ne rien mettre et pour l'axe des _y_ : _"Par portion de 100g"_
        + Masquer la l√©gende
4. Encapsuler ce code dans une fonction nomm√©e `figure_infos_nutritionnelles` dont les arguments
sont `data`, `variable_nutritionnelle = 'energy-kcal_100g'`, `coicop = "01.1.7.3.2"` et `valeur_produit = 8`.


```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "Mod√®le de figure pour les qualit√©s nutritionnelles (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Pour pr√©parer cet exercice, cr√©er les objets suivants:

```python
data = stats_nutritionnelles.copy()
variable_nutritionnelle = 'energy-kcal_100g'
coicop = "01.1.7.3.2"
valeur_produit = 8
```

1. Utiliser la m√©thode [`loc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html)
pour ne conserver que les observations o√π `data['variable']` est √©gale √† la valeur `variable_nutritionnelle`
et o√π la variable `coicop` est √©gale √† la valeur `coicop` (qu'on a fix√© √† `"01.1.7.3.2"`). A l'issue de ces
filtres, nommer le dataframe obtenu `example_coicop`
2. Utiliser [`np.where`](https://numpy.org/doc/stable/reference/generated/numpy.where.html) pour cr√©er une 
colonne stockant les couleurs de notre graphique. On utilisera le rouge (_red_) lorsque la variable quantile
est √©gale √† `valeur_produit` et du bleu (_royalblue_) sinon. Nommer cette variable `color`.
3. Cr√©er un diagramme en barre avec:
        + sur l'axe des _x_ les quantiles (stock√©s dans la variable `quantile`)
        + sur l'axe des _y_, la valeur √† repr√©senter (stock√©e dans la variable `value`)
        + la couleur √† partir de la variable `color`
        + Les _labels_ : pour l'axe des _x_ ne rien mettre et pour l'axe des _y_ : _"Par portion de 100g"_
        + Masquer la l√©gende via l'argument `showlegend` de la m√©thode `update_layout` 
4. Encapsuler ce code dans une fonction nomm√©e `figure_infos_nutritionnelles` dont les arguments
sont `data`, `variable_nutritionnelle = 'energy-kcal_100g'`, `coicop = "01.1.7.3.2"` et `valeur_produit = 8`.

```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::




```{python}
# Solution pour voie üü°
import numpy as np
import plotly.express as px

def figure_infos_nutritionnelles(
    data, variable_nutritionnelle = 'energy-kcal_100g',
    coicop = "01.1.7.3.2", valeur_produit = 8
    ):
    
    example_coicop = data.loc[data['variable'] == variable_nutritionnelle]
    example_coicop = example_coicop.loc[example_coicop['coicop']==coicop]
    example_coicop['color'] = np.where(example_coicop['quantile'] == valeur_produit, "red", "royalblue")

    fig = px.bar(
        example_coicop,
        x='quantile', y='value', color = "color", template = "simple_white",
        title=variable_nutritionnelle,
        labels={
            "quantile": "",
            "value": "Par portion de 100g"
        }
    )
    fig.update_layout(showlegend=False)
    fig.update_layout(hovermode="x")
    fig.update_traces(
        hovertemplate="<br>".join([
            "Dixi√®me n¬∞ %{x}",
            f"{variable_nutritionnelle}: " + " au moins %{y} par portion de 100g"
        ])
    )
    return fig
```

```{python}
#| output: false
from utils.construct_figures import figure_infos_nutritionnelles
fig = figure_infos_nutritionnelles(stats_nutritionnelles)
fig.update_layout(width=800, height=400)

fig
```

::: {.cell .markdown}
<!----- boite ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "‚ö´", title = "Mod√®le de figure pour les notes (‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction standardis√©e qui pr√©sente, sous forme de diagramme en barre,
le nombre de produits dans une classe de produit donn√©e (identifi√©e par la COICOP)
de chaque d√©cile.

```{=html}
</details>
</div>
```

<!----- end ‚ö´ ----->
:::


::: {.cell .markdown}
<!----- boite üî¥ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üî¥", title = "Mod√®le de figure pour les notes (üî¥)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Cr√©er une fonction standardis√©e dont les arguments sont

- Un jeu de donn√©es nomm√© `data`
- Une caract√©ristique nutritionnelle nomm√©e `variable_note` par d√©faut √©gale √† `nutriscore_grade`
- Une cat√©gorie nomm√©e `coicop`, par d√©faut √©gale √† `01.1.7.3.2`
- Une note pour le produit dans une variable nomm√©e `note_produit` par d√©faut √©gal √† `B`

Cette fonction effectue les t√¢ches suivantes:

- Ne conserver, dans notre ensemble de valeurs agr√©g√©es, que celles relatives √† la COICOP et
√† la caract√©ristique nutritionnelle qu'on recherche ;
- Repr√©senter sous forme de diagramme en barre les valeurs nutritionnelles pour chaque d√©cile de la 
distribution avec, en rouge, celle de notre produit (`valeur_produit`)

```{=html}
</details>
</div>
```

<!----- end üî¥ ----->
:::

::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Mod√®le de figure pour les notes (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Pour pr√©parer cet exercice, cr√©er les objets suivants:

```python
data = stats_nutritionnelles.copy()
variable_note = 'nutriscore_grade'
coicop = "01.1.7.3.2"
note_produit = "B"
```

1. Ne conserver que les observations o√π `data['variable']` est √©gale √† la valeur `variable_note`
et o√π la variable `coicop` est √©gale √† la valeur `coicop`. A l'issue de ces
filtres, nommer le dataframe obtenu `example_coicop`
2. Cr√©er une 
colonne stockant les couleurs de notre graphique. On utilisera le rouge (_red_) lorsque la variable quantile
est √©gale √† `note_produit` et du bleu (_royalblue_) sinon. Nommer cette variable `color`.
3. Cr√©er un diagramme en barre avec:
        + sur l'axe des _x_ les quantiles
        + sur l'axe des _y_, la valeur √† repr√©senter
        + la couleur √† partir de la variable `color`
        + Les _labels_ : pour l'axe des _x_ ne rien mettre et pour l'axe des _y_ : _"Note"_
        + Masquer la l√©gende
4. Encapsuler ce code dans une fonction nomm√©e `figure_infos_nutritionnelles` dont les arguments
sont `data`, `variable_nutritionnelle = 'nutriscore_grade'`, `coicop = "01.1.7.3.2"` et `note_produit = "B"`.


```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "Mod√®le de figure pour les notes (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Pour pr√©parer cet exercice, cr√©er les objets suivants:

```python
data = stats_nutritionnelles.copy()
variable_note = 'nutriscore_grade'
coicop = "01.1.7.3.2"
note_produit = "B"
```

1. Utiliser la m√©thode [`loc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html)
pour ne conserver que les observations o√π `data['variable']` est √©gale √† la valeur `variable_note`
et o√π la variable `coicop` est √©gale √† la valeur `coicop` (qu'on a fix√© √† `"01.1.7.3.2"`). A l'issue de ces
filtres, nommer le dataframe obtenu `example_coicop`
2. Utiliser [`np.where`](https://numpy.org/doc/stable/reference/generated/numpy.where.html) pour cr√©er une 
colonne stockant les couleurs de notre graphique. On utilisera le rouge (_red_) lorsque la variable quantile
est √©gale √† `note_produit` et du bleu (_royalblue_) sinon. Nommer cette variable `color`.
3. Cr√©er un diagramme en barre avec:
        + sur l'axe des _x_ les notes (stock√©s dans la variable `note`)
        + sur l'axe des _y_, la valeur √† repr√©senter (stock√©e dans la variable `value`)
        + la couleur √† partir de la variable `color`
        + Les _labels_ : pour l'axe des _x_ ne rien mettre et pour l'axe des _y_ : _"Note"_
        + Masquer la l√©gende via l'argument `showlegend` de la m√©thode `update_layout` 
4. Encapsuler ce code dans une fonction nomm√©e `figure_infos_nutritionnelles` dont les arguments
sont `data`, `variable_nutritionnelle = 'nutriscore_grade'`, `coicop = "01.1.7.3.2"` et `valeur_produit = "B"`.

```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::


```{python}
import plotly.express as px
import numpy as np

def figure_infos_notes(
    data, variable_note = 'nutriscore_grade',
    coicop = "01.1.7.3.2", note_produit = "B"
):
    example_coicop = data.loc[data['variable'] == variable_note]
    example_coicop = example_coicop.loc[example_coicop['coicop']==coicop]
    example_coicop['color'] = np.where(example_coicop['note'] == note_produit, "red", "royalblue")

    fig = px.bar(
        example_coicop,
        x='note', y='value', color = "color", template = "simple_white",
        title=variable_note,
        labels={
            "note": "Note",
            "value": ""
        }
    )
    fig.update_xaxes(
        categoryorder='array',
        categoryarray= ['A', 'B', 'C', 'D', 'E'])
    fig.update_layout(showlegend=False)
    fig.update_layout(hovermode="x")
    fig.update_traces(
        hovertemplate="<br>".join([
            "Note %{x}",
            f"{variable_note}: " +" %{y} produits"
        ])
    )

    return fig
```

```{python}
#| output: false
from utils.construct_figures import figure_infos_notes
fig = figure_infos_notes(stats_notes)
fig.update_layout(width=800, height=400)

fig
```

