# 2ï¸âƒ£ Faire des statistiques agrÃ©gÃ©es par catÃ©gories

Cette partie permet de calculer en amont de l'application des
statistiques descriptives qui pourront Ãªtre utilisÃ©es
par celle-ci. 

Il est prÃ©fÃ©rable de minimiser la quantitÃ© de calculs
faits Ã  la volÃ©e dans le cadre d'une application. Sinon,
le risque est une latence embÃªtante pour l'utilisateur
voire un crash du serveur Ã  cause de besoins
de ressources trop importants.

Cette partie propose ainsi de crÃ©er en avance une
base de donnÃ©es synthÃ©tisant 
le
nombre de produits dans une catÃ©gorie donnÃ©e (par exemple les
fromages Ã  pÃ¢te crue) qui partagent la mÃªme note.
Cela nous permettra d'afficher des statistiques personnalisÃ©es
sur les produits similaires Ã  celui qu'on scanne. 


## 2.1. PrÃ©liminaires (ğŸŸ¡,ğŸŸ¢,ğŸ”µ,ğŸ”´,âš«)


Sur le plan technique, cette partie propose deux cadres de manipulation
de donnÃ©es diffÃ©rents,
selon le balisage de la voie:

- ğŸŸ¡,ğŸŸ¢,ğŸ”µ: utilisation de `Pandas`
- ğŸ”´,âš«: requÃªtes SQL directement sur le fichier `Parquet` grÃ¢ce Ã  `DuckDB`

La deuxiÃ¨me approche permet de mettre en oeuvre des calculs plus efficaces
(`DuckDB`) est plus rapide mais nÃ©cessite un peu plus d'expertise sur la
manipulation de donnÃ©es, notamment des connaissances en SQL. 

Cette partie va fonctionner en trois temps:

1. Lecture des donnÃ©es `OpenFoodFacts` prÃ©cÃ©demment produites
2. Construction de statistiques descriptives standardisÃ©es
3. Construction de graphiques Ã  partir de ces statistiques descriptives

Les Ã©tapes 1 et 2 sont sÃ©parÃ©es conceptuellement pour les parcours ğŸŸ¡,ğŸŸ¢,ğŸ”µ. 
Pour les parcours ğŸ”´ et âš«, l'utilisation de requÃªtes SQL fait que ces
deux Ã©tapes conceptuelles sont intriquÃ©es. Les parcours ğŸŸ¡,ğŸŸ¢,ğŸ”µ
peuvent observer les morceaux de code proposÃ©s dans le cadre ğŸ”´ et âš«,
c'est assez instructif. L'Ã©tape 3 (production de graphiques)
sera la mÃªme pour tous les parcours. 

::: {.cell .markdown}
```{=html}
<div class="alert alert-warning" role="alert" style="color: rgba(0,0,0,.8); background-color: white; margin-top: 1em; margin-bottom: 1em; margin:1.5625emauto; padding:0 .6rem .8rem!important;overflow:hidden; page-break-inside:avoid; border-radius:.25rem; box-shadow:0 .2rem .5rem rgba(0,0,0,.05),0 0 .05rem rgba(0,0,0,.1); transition:color .25s,background-color .25s,border-color .25s ; border-right: 1px solid #dee2e6 ; border-top: 1px solid #dee2e6 ; border-bottom: 1px solid #dee2e6 ; border-left:.2rem solid #ffc10780;">
<h3 class="alert-heading"><i class="fa fa-lightbulb-o"></i> Hint</h3>
```

Cette partie peut Ãªtre faite sans avoir suivie la prÃ©cÃ©dente. 
Il est alors recommandÃ© d'effectuer deux actions:

1. Dans le fichier `config.yaml`, remplacer `"projet-funathon"` par votre nom
d'utilisateur sur le `SSP Cloud`
2. CrÃ©er une cellule en copiant-collant le texte suivant et
en remplacant `<USERNAME_SSPCLOUD>` par votre nom d'utilisateur sur le SSPCloud. 

```python
# crÃ©er une cellule de code et copier dedans ce texte
# remplacer `<USERNAME_SSPCLOUD>` par votre nom d'utilisateur sur le SSPCloud
!mc cp s3/projet-funathon/2023/sujet4/diffusion/openfood.parquet s3/<USERNAME_SSPCLOUD>/2023/sujet4/diffusion/openfood.parquet
```

âš ï¸ __Il faut avoir modifiÃ© la valeur de `USERNAME_SSPCLOUD` pour
que cette commande fonctionne__. 


Cette commande permet de copier le fichier d'exemple que nous avons
mis Ã  disposition vers votre espace personnel.

```{=html}
</div>
```
:::


Nous proposons d'importer Ã  nouveau nos configurations:

```{python}
from utils.import_yaml import import_yaml
config = import_yaml("config.yaml")
```

Les colonnes suivantes nous seront utiles dans cette partie:

```{python}
indices_synthetiques = [
    "nutriscore_grade", "ecoscore_grade", "nova_group"
]
principales_infos = ['product_name', 'code', 'preprocessed_labels', 'coicop']
```

Voici, Ã  nouveau, la configuration pour permettre Ã  `Python`
de communiquer avec l'espace de stockage distant:

```{python}
import s3fs

config = import_yaml("config.yaml")
INPUT_OPENFOOD = f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/openfood.parquet"

# Initialisation de la connexion
fs = s3fs.S3FileSystem(
    client_kwargs={"endpoint_url": config["ENDPOINT_S3"]}
)
```


## 2.2. Import des donnÃ©es depuis l'espace de stockage distant avec `Pandas` (ğŸŸ¡,ğŸŸ¢,ğŸ”µ)

Il est recommandÃ© pour les parcours ğŸŸ¡, ğŸŸ¢, ğŸ”µ de travailler avec `Pandas` pour construire
des statistiques descriptives. Cela se fera en deux Ã©tapes:

- Import des donnÃ©es directement depuis l'espace de stockage, sans Ã©criture intermÃ©diaire sur le disque local,
puis nettoyage de celles-ci ;
- Construction de fonctions standardisÃ©es pour la production de statistiques descriptives.

### Import et nettoyage des donnÃ©es `OpenFoodFacts` (ğŸŸ¡, ğŸŸ¢ et ğŸ”µ)

Il est possible de lire un CSV de plusieurs maniÃ¨res avec `Python`.
L'une d'elle se fait Ã  travers le _[context manager](https://book.pythontips.com/en/latest/context_managers.html#context-managers)_. 
Le module `s3fs` permet d'utiliser ce _context manager_ pour lire un fichier distant, 
de maniÃ¨re trÃ¨s similaire Ã  la lecture d'un fichier local. 

::: {.cell .markdown}
<!----- boite ğŸ”µ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "Lire les donnÃ©es depuis un espace distant (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

A partir du _context manager_ intÃ©grÃ© Ã  `s3fs`, lire
les donnÃ©es en suivant les consignes suivantes:

- la localisation des donnÃ©es est stockÃ©e dans la variable `INPUT_OPENFOOD`
- Utiliser l'option `columns = principales_infos + indices_synthetiques`
pour n'importer que les variables nÃ©cessaires.

```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::


::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Lire les donnÃ©es depuis un espace distant (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

Lors de l'Ã©criture du fichier nous avons utilisÃ© la commande suivante:

```python
# Ecriture au format parquet sur l'espace de stockage distant
with fs.open(DESTINATION_OPENFOOD, "wb") as file_location:
    openfood.to_parquet(file_location)
```

Nous proposons de suivre la mÃªme logique en changeant quelques Ã©lÃ©ments:

- La variable de chemin Ã  utiliser ici est `INPUT_OPENFOOD` ;
- Le contexte n'est plus Ã  l'Ã©criture (_"wb"_) mais Ã  la lecture (_"rb"_) ;
- La commande Ã  exÃ©cuter dans ce contexte n'est plus l'Ã©criture d'un fichier parquet
mais `pd.read_parquet`. Utiliser
l'option `columns = principales_infos + indices_synthetiques`
pour n'importer que les variables nÃ©cessaires.

```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::


```{python}
#| classes: yellow-code
#| label: get-openfood-parquet-2
#| output: false

# Solution pour voie ğŸŸ¡, ğŸŸ¢ et ğŸ”µ
import pandas as pd

# methode 1: pandas
with fs.open(INPUT_OPENFOOD, "rb") as remote_file:
    openfood = pd.read_parquet(
        remote_file,
        columns = principales_infos + \
        indices_synthetiques
    )
```

Les donnÃ©es ont ainsi l'aspect suivant:

```{python}
openfood.head(2)
```

## 2.3. Statistiques descriptives (ğŸŸ¡, ğŸŸ¢ et ğŸ”µ)

On dÃ©sire calculer pour chaque classe de
produits - par exemple les boissons rafraichissantes - 
le nombre de produits qui partagent une mÃªme note pour chaque
indicateur de qualitÃ© nutritionnelle ou environnementale.

Nous allons utiliser le `DataFrame` suivant pour les calculs de notes:

```{python}
openfood_notes = openfood.loc[:,["coicop"] + indices_synthetiques]
```


::: {.cell .markdown}
<!----- boite ğŸ”µ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "Distribution des notes par catÃ©gorie de produit (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

1. Pour chaque valeur de la variable `coicop`,
avec la mÃ©thode `agg`, effectuer un dÃ©compte des notes (`value_counts` en `Pandas`)
pour chaque variable de la liste `indices_synthetiques` grÃ¢ce Ã  la mÃ©thode `agg`.
Renommer ensuite les deux variables d'index 'coicop' et 'note' grÃ¢ce Ã  la mÃ©thode `reset_index`

2. Pivoter les donnÃ©es vers un format _long_
via les axes `coicop` et `note`

3. DÃ©dupliquer les donnÃ©es en ne gardant que les paires uniques sur les variables
`variable, note, coicop`

```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::


::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Distribution des notes par catÃ©gorie de produit (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

1. AprÃ¨s un `groupby("coicop")`, effectuer un dÃ©compte des notes (`value_counts` en `Pandas`)
pour chaque variable de la liste `indices_synthetiques` grÃ¢ce Ã  la mÃ©thode `agg`
puis renommer les deux variables d'index 'coicop' et 'note' grÃ¢ce Ã  la mÃ©thode `reset_index`

```{=html}
<details>
<summary>RÃ©ponse en cas de difficultÃ©</summary>
```

```python
stats_notes = (
    openfood_notes
    .groupby("coicop")
    .agg({i:'value_counts' for i in indices_synthetiques})
    .reset_index(names=['coicop', 'note'])
)
```

```{=html}
</details>

```

2. Utiliser `pd.melt` pour pivoter les donnÃ©es vers un format _long_
via les axes `coicop` et `note`

3. DÃ©dupliquer les donnÃ©es en ne gardant que les paires uniques sur les variables
`variable, note, coicop` grÃ¢ce Ã  la mÃ©thode `drop_duplicates`

```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::



```{python}
# Solution pour voie ğŸŸ¡, ğŸŸ¢ et ğŸ”µ
def compute_stats_grades(data, indices_synthetiques):
    stats_notes = (
        data
        .groupby("coicop")
        .agg({i:'value_counts' for i in indices_synthetiques})
        .reset_index(names=['coicop', 'note'])
    )
    stats_notes = pd.melt(stats_notes, id_vars = ['coicop','note'])
    stats_notes = stats_notes.dropna().drop_duplicates(subset = ['variable','note','coicop'])
    stats_notes['value'] = stats_notes['value'].astype(int)
  
    return stats_notes

stats_notes = compute_stats_grades(openfood_notes, indices_synthetiques)
```

## 2.4. Import et traitement des donnÃ©es avec `DuckDB` (ğŸ”´ et âš«)

Cette partie propose pour les parcours ğŸ”´ et âš« de reproduire l'analyse faite par
les parcours ğŸŸ¡,ğŸŸ¢ et ğŸ”µ via `Pandas`. 

`DuckDB` va Ãªtre utilisÃ© pour lire et agrÃ©ger les donnÃ©es. 
Pour lire directement depuis un systÃ¨me de stockage distant, sans prÃ©-tÃ©lÃ©charger les 
donnÃ©es, vous pouvez utiliser la configuration suivante de `DuckDB`:

```{python}
import duckdb
con = duckdb.connect(database=':memory:')
con.execute("""
    INSTALL httpfs;
    LOAD httpfs;
    SET s3_endpoint='minio.lab.sspcloud.fr'
""")
```

Et voici un exemple minimal de lecture de donnÃ©es Ã  partir du chemin
`INPUT_OPENFOOD` dÃ©fini prÃ©cÃ©demment. 

```{python}
duckdb_data = con.sql(
    f"SELECT product_name, preprocessed_labels, coicop, energy_100g FROM read_parquet('s3://{INPUT_OPENFOOD}') LIMIT 10"
)
duckdb_data.df() #conversion en pandas dataframe
```

Nous proposons de crÃ©er une unique requÃªte SQL qui, dans une clause `SELECT`,
pour chaque classe de produit (notre variable de COICOP),
compte le nombre de produits qui partagent une mÃªme note. 


::: {.cell .markdown}
<!----- boite âš« ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "âš«", title = "Distribution des notes par catÃ©gorie de produit (âš«)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

- CrÃ©er une fonction `count_one_variable_sql` prenant un argument nommÃ© `con` (connexion DuckDB),
un argument `variable` (par dÃ©faut Ã©gal Ã  `nova_group`) et un chemin de lecture des donnÃ©es
dans le systÃ¨me `S3`. Cette fonction agrÃ¨ge calcule la statistique descriptive dÃ©sirÃ©e 
pour `variable`.
- CrÃ©er le `DataFrame` qui combine toutes ces statistiques pour les
variables `["nutriscore_grade", "ecoscore_grade", "nova_group"]`.
Celui-ci comporte quatre variables: `coicop`, `note`, `value` et `variable`.

```{=html}
</details>
</div>
```

<!----- end âš« ----->
:::


::: {.cell .markdown}
<!----- boite ğŸ”´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”´", title = "Distribution des notes par catÃ©gorie de produit (ğŸ”´)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

CrÃ©er une fonction `count_one_variable_sql` prenant un argument nommÃ© `con` (connexion DuckDB),
un argument `variable` (par dÃ©faut Ã©gal Ã  `nova_group`) et un chemin de lecture des donnÃ©es
dans le systÃ¨me `S3`.

Cette fonction effectue les opÃ©rations suivantes:

- CrÃ©er un `DataFrame` `Pandas` aprÃ¨s avoir agrÃ©gÃ© les donnÃ©es via `DuckDB` grÃ¢ce
au modÃ¨le de requÃªte

```python
f"SELECT coicop, {variable} AS note, COUNT({variable}) AS value FROM read_parquet('s3://{path_within_s3}') GROUP BY coicop, {variable}"
```

- CrÃ©e une variable `variable` Ã©gale Ã  la valeur de l'argument `variable`

- CrÃ©er le `DataFrame` qui combine toutes ces statistiques de la maniÃ¨re suivante
en appliquant la fonction de maniÃ¨re rÃ©pÃ©tÃ©e :

```python
grades = ["nutriscore_grade", "ecoscore_grade", "nova_group"]
stats_notes_sql = [count_one_variable_sql(con, note, INPUT_OPENFOOD) for note in grades]
stats_notes_sql = pd.concat(stats_notes_sql)
```

```{=html}
</details>
</div>
```

<!----- end ğŸ”´ ----->
:::

```{python}
# Solution Ã  la voie ğŸ”´ et âš« pour les curieux de la voie ğŸŸ¡, ğŸŸ¢ et ğŸ”µ
def count_one_variable_sql(con, variable, path_within_s3 = "temp.parquet"):
    query = f"SELECT coicop, {variable} AS note, COUNT({variable}) AS value FROM read_parquet('s3://{path_within_s3}') GROUP BY coicop, {variable}"
    stats_one_variable = con.sql(query).df().dropna()
    stats_one_variable['variable'] = variable
    stats_one_variable = stats_one_variable.replace('', 'NONE')

    return stats_one_variable

grades = ["nutriscore_grade", "ecoscore_grade", "nova_group"]
stats_notes_sql = [count_one_variable_sql(con, note, INPUT_OPENFOOD) for note in grades]
stats_notes_sql = pd.concat(stats_notes_sql)
```

Ceci nous donne donc le `DataFrame` suivant:

```{python}
stats_notes_sql.head(2)
```

## 2.5. Sauvegarde dans l'espace de stockage distant (ğŸŸ¡,ğŸŸ¢,ğŸ”µ,ğŸ”´,âš«)

Ces statistiques descriptives sont Ã  Ã©crire dans l'espace de stockage
distant pour ne plus avoir Ã  les calculer. 

```{python}
#| eval: false
def write_stats_to_s3(data, destination):
    # Ecriture au format parquet sur l'espace de stockage distant
    with fs.open(destination, "wb") as file_location:
        data.to_parquet(file_location)

write_stats_to_s3(stats_notes, f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/stats_notes_pandas.parquet")
write_stats_to_s3(stats_notes_sql, f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/stats_notes_sql.parquet")
```

âš ï¸ __Il faut avoir modifiÃ© la valeur de `BUCKET` dans le fichier `config.yaml` pour
que cette commande fonctionne__. 



## 2.6. CrÃ©ation d'un modÃ¨le de graphiques (ğŸŸ¡,ğŸŸ¢,ğŸ”µ,ğŸ”´,âš«)

On va utiliser `Plotly` pour crÃ©er des graphiques et, ultÃ©rieurement,
les afficher sur notre page web. Cela permettra d'avoir un peu de
rÃ©activitÃ©, c'est l'intÃ©rÃªt de faire un format _web_ plutÃ´t qu'une
publication figÃ©e comme un `PDF`. 


::: {.cell .markdown}
<!----- boite âš« ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "âš«", title = "ModÃ¨le de figure pour les notes (âš«)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

CrÃ©er une fonction standardisÃ©e dont l'_output_ est un objet `Plotly` 
respectant le cahier des charges suivant, pour chaque classe de produit : 

- Diagramme en barre prÃ©sentant 
le nombre de produits ayant telle ou telle note
- PrÃ©voir un argument pour mettre en surbrillance une valeur donnÃ©e
(par exemple la note `B`). 
- PrÃ©voir un argument pour le titre du graphique

```{=html}
</details>
</div>
```

<!----- end âš« ----->
:::


::: {.cell .markdown}
<!----- boite ğŸ”´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”´", title = "ModÃ¨le de figure pour les notes (ğŸ”´)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

CrÃ©er une fonction standardisÃ©e dont les arguments sont

- Un jeu de donnÃ©es nommÃ© `data`
- Une caractÃ©ristique nutritionnelle nommÃ©e `variable_note` par dÃ©faut Ã©gale Ã  `nutriscore_grade`
- Une catÃ©gorie nommÃ©e `coicop`, par dÃ©faut Ã©gale Ã  `01.1.7.3.2`
- Une note pour le produit dans une variable nommÃ©e `note_produit` par dÃ©faut Ã©gal Ã  `B`
- Un titre par dÃ©faut Ã©gal Ã  `Nutriscore`

Cette fonction effectue les tÃ¢ches suivantes:

- Ne conserver, dans notre ensemble de valeurs agrÃ©gÃ©es, que celles relatives Ã  la COICOP et
Ã  la caractÃ©ristique nutritionnelle qu'on recherche ;
- ReprÃ©senter sous forme de diagramme en barre les valeurs nutritionnelles pour chaque dÃ©cile de la 
distribution avec, en rouge, celle de notre produit (`valeur_produit`)
- N'hÃ©sitez pas Ã  utiliser les options de `Plotly` pour personnaliser la figure

```{=html}
</details>
</div>
```

<!----- end ğŸ”´ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸ”µ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "ModÃ¨le de figure pour les notes (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

Pour prÃ©parer cet exercice, crÃ©er les objets suivants:

```python
data = stats_nutritionnelles.copy()
variable_note = 'nutriscore_grade'
coicop = "01.1.7.3.2"
note_produit = "B"
titre = "Nutriscore"
```

1. Ne conserver que les observations oÃ¹ `data['variable']` est Ã©gale Ã  la valeur `variable_note`
et oÃ¹ la variable `coicop` est Ã©gale Ã  la valeur `coicop`. A l'issue de ces
filtres, nommer le dataframe obtenu `example_coicop`
2. CrÃ©er une 
colonne stockant les couleurs de notre graphique. Nommer cette variable `color`.
3. CrÃ©er un diagramme en barre avec:
        + sur l'axe des _x_ les quantiles
        + sur l'axe des _y_, la valeur Ã  reprÃ©senter
        + la couleur Ã  partir de la variable `color`
        + Les _labels_ : pour l'axe des _x_ ne rien mettre et pour l'axe des _y_ : _"Note"_
        + Masquer la lÃ©gende
        + Le titre Ã  partir de la variable `titre` 
4. Encapsuler ce code dans une fonction nommÃ©e `figure_infos_notes` dont les arguments
sont les variables prÃ©cÃ©demment crÃ©es.

```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "ModÃ¨le de figure pour les notes (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

Pour prÃ©parer cet exercice, crÃ©er les objets suivants:

```python
data = stats_nutritionnelles.copy()
variable_note = 'nutriscore_grade'
coicop = "01.1.7.3.2"
note_produit = "B"
titre = "Nutriscore"
```

1. Utiliser la mÃ©thode [`loc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html)
pour ne conserver que les observations oÃ¹ `data['variable']` est Ã©gale Ã  la valeur `variable_note`
et oÃ¹ la variable `coicop` est Ã©gale Ã  la valeur `coicop` (qu'on a fixÃ© Ã  `"01.1.7.3.2"`). A l'issue de ces
filtres, nommer le dataframe obtenu `example_coicop`
2. Utiliser [`np.where`](https://numpy.org/doc/stable/reference/generated/numpy.where.html) pour crÃ©er une 
colonne stockant les couleurs de notre graphique. On utilisera le rouge (_red_) lorsque la variable quantile
est Ã©gale Ã  `note_produit` et du bleu (_royalblue_) sinon. Nommer cette variable `color`.
3. CrÃ©er un diagramme en barre avec:
        + sur l'axe des _x_ les notes (stockÃ©s dans la variable `note`)
        + sur l'axe des _y_, la valeur Ã  reprÃ©senter (stockÃ©e dans la variable `value`)
        + la couleur Ã  partir de la variable `color`
        + Les _labels_ : pour l'axe des _x_ ne rien mettre et pour l'axe des _y_ : _"Note"_
        + Masquer la lÃ©gende via l'argument `showlegend` de la mÃ©thode `update_layout` 
        + Le titre Ã  partir de la variable `titre` 
4. Encapsuler ce code dans une fonction nommÃ©e `figure_infos_nutritionnelles` dont les arguments
sont `data`, `variable_nutritionnelle = 'nutriscore_grade'`, `coicop = "01.1.7.3.2"` et `valeur_produit = "B"`.

```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::

Voici un exemple de fonction qui rÃ©pond aux 
cahiers des charges ci-dessus:

```{python}
#Â Solution pour voie ğŸŸ¡

import plotly.express as px
import numpy as np

def figure_infos_notes(
    data, variable_note = 'nutriscore_grade',
    coicop = "01.1.7.3.2", note_produit = "B",
    title = "Nutriscore"
):
    example_coicop = data.loc[data['variable'] == variable_note]
    example_coicop = example_coicop.loc[example_coicop['coicop']==coicop]
    example_coicop['color'] = np.where(example_coicop['note'] == note_produit, "Note du produit", "Autres produits")

    fig = px.bar(
        example_coicop,
        x='note', y='value', color = "color", template = "simple_white",
        title=title,
        color_discrete_map={"Note produit": "red", "Autres produits": "royalblue"},
        labels={
            "note": "Note",
            "value": ""
        }
    )
    fig.update_xaxes(
        categoryorder='array',
        categoryarray= ['A', 'B', 'C', 'D', 'E'])
    fig.update_layout(showlegend=False)
    fig.update_layout(hovermode="x")
    fig.update_traces(
        hovertemplate="<br>".join([
            "Note %{x}",
            f"{variable_note}: " +" %{y} produits"
        ])
    )

    return fig
```

Voici un exemple d'utilisation

```{python}
#| output: false
from utils.construct_figures import figure_infos_notes
fig = figure_infos_notes(stats_notes)
fig.update_layout(width=800, height=400)

fig
```

