#¬†1Ô∏è‚É£ R√©cup√©ration des donn√©es `OpenFoodFacts`

## 1.1. Pr√©liminaire (üü°,üü¢,üîµ,üî¥,‚ö´)

Comme nous allons utiliser fr√©quemment certains param√®tres,
une bonne pratique consiste √† les stocker dans un fichier
d√©di√©, au format `YAML` et d'importer celui-ci via
`Python`. Ceci est expliqu√© dans [ce cours de l'ENSAE](https://ensae-reproductibilite.github.io/website/chapters/application.html#etape-3-gestion-des-param%C3%A8tres)

Nous proposons de cr√©er le fichier suivant au nom `config.yaml`:

```yaml
URL_OPENFOOD: "https://static.openfoodfacts.org/data/en.openfoodfacts.org.products.csv.gz"
ENDPOINT_S3: "https://minio.lab.sspcloud.fr"
BUCKET: "projet-funathon"
DESTINATION_DATA_S3: "/2023/sujet4/diffusion"
URL_FASTTEXT_MINIO: "https://minio.lab.sspcloud.fr/projet-funathon/2023/sujet4/diffusion/model_coicop10.bin"
URL_COICOP_LABEL: "https://www.insee.fr/fr/statistiques/fichier/2402696/coicop2016_liste_n5.xls"
```

‚ö†Ô∏è Si vous d√©sirez pouvoir reproduire tous les exemples de ce fichier, vous devez
changer la variable `BUCKET` pour mettre votre nom d'utilisateur sur le `SSPCloud`.

Nous allons lire ce fichier avec le package adapt√© pour transformer ces
instructions en variables `Python` (stock√©es dans un dictionnaire)!,



::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "Utiliser un fichier YAML (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

A partir des exemples pr√©sents dans [cette page](https://stackoverflow.com/questions/1773805/how-can-i-parse-a-yaml-file-in-python),
importer les variables dans un objet `Python` nomm√© `config`

```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::

::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Utiliser un fichier YAML (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Utiliser le package `PyYAML` pour importer les √©l√©ments pr√©sents dans `config.yaml` dans un objet `Python` nomm√© `config`

```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üî¥,‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üî¥", title = "Utiliser un fichier YAML (üî¥,‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Importer les √©l√©ments pr√©sents dans `config.yaml` dans un objet `Python` nomm√© `config`

```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::



```{python}
#| classes: yellow-code

#¬†Solution pour voie üü°
import yaml

def import_yaml(filename: str) -> dict:
    """
    Importer un fichier YAML

    Args:
        filename (str): Emplacement du fichier

    Returns:
        dict: Le fichier YAML sous forme de dictionnaire Python
    """
    with open(filename, "r", encoding="utf-8") as stream:
        config = yaml.safe_load(stream)
        return config

import_yaml("config.yaml")
```

Il est recommand√© pour la suite de
copier-coller la fonction cr√©√©e (ne pas oublier les imports associ√©s) 
dans un fichier √† l'emplacement `utils/import_yaml.py`. Cette approche modulaire est
une bonne
pratique, recommand√©e
dans [ce cours de l'ENSAE](https://ensae-reproductibilite.github.io/website/).

Pour la voie üü°, ce fichier a d√©j√† √©t√© cr√©√© pour vous. 
Le tester de la mani√®re suivante:

```{python}
#| classes: yellow-code

#¬†Solution pour voie üü°
from utils.import_yaml import import_yaml
config = import_yaml("config.yaml")
```


## 1.2. T√©l√©charger et nettoyer la base `OpenFoodFacts` (üü°,üü¢,üîµ,üî¥,‚ö´)

Un export quotidien de la
base de donn√©es `OpenFoodFacts` est fourni au format `CSV`. L'URL est le suivant:

```{python}
config["URL_OPENFOOD"]
```

Il est possible d'importer de plusieurs mani√®res ce type de fichier avec `Python`. 
Ce qu'on propose ici, 
c'est de le faire en deux temps, afin d'avoir un contr√¥le des 
options mises en oeuvre lors de l'import (notamment le format de certaines variables) :

- Utiliser `requests` pour t√©l√©charger le fichier et l'√©crire, de mani√®re interm√©diaire, 
sur le disque local ;
- Utiliser `pandas` avec quelques options pour importer le fichier puis le manipuler. 


::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "T√©l√©charger et importer OpenFoodFacts (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. Utiliser la fonction `requests.get` pour t√©l√©charger le fichier.
Vous pouvez vous inspirer de r√©ponses [ici](https://stackoverflow.com/questions/16694907/download-large-file-in-python-with-requests)


2. Utiliser `pd.read_csv` avec les options suivantes:
        + Le fichier utilise `\t` comme tabulation
        + Utiliser l'argument `parse_dates=["created_datetime", "last_modified_datetime", "last_image_datetime"]`
        + Il est n√©cessaire de figer quelques types avec l'argument `dtype`. Voici le dictionnaire √† passer
        
```python
{
    "code ": "str",
    "emb_codes": "str",
    "emb_codes_tags": "str",
    "energy_100g": "float",
    "alcohol_100g": "float",
}
```

3. Forcer la colonne `code` √† √™tre de type _string_ avec la m√©thode `.astype(str)`

```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::

::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "T√©l√©charger et importer OpenFoodFacts (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. Utiliser le _package_ `requests` pour t√©l√©charger le fichier. Si vous voulez afficher une barre de progression,
vous pouvez vous inspirer de la fonction `download_pb` du package [`cartiflette`](https://github.com/InseeFrLab/cartiflette)

2. Lire les donn√©es avec `pandas` avec les options suivantes:
        + Le fichier utilise `\t` comme tabulation
        + Utiliser l'argument `parse_dates = ["created_datetime", "last_modified_datetime", "last_image_datetime"]`
        + Il est n√©cessaire de figer, voici le dictionnaire √† passer
        
```python
{
    "code ": "str",
    "emb_codes": "str",
    "emb_codes_tags": "str",
    "energy_100g": "float",
    "alcohol_100g": "float",
}
```

3. Forcer la colonne `code` √† √™tre de type _string_

```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üî¥,‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "T√©l√©charger et importer OpenFoodFacts (üî¥,‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. T√©l√©charger le fichier avec `Python`. Pour s'assurer de la progression du t√©l√©chargement, 
utiliser √©galement la librairie `tqdm`.

2. Lire les donn√©es avec `pandas` avec les options suivantes:
        + Le fichier utilise `\t` comme tabulation
        + Utiliser l'argument `parse_dates = ["created_datetime", "last_modified_datetime", "last_image_datetime"]`
        + Il est n√©cessaire de figer, voici le dictionnaire √† passer
        
```python
{
    "code ": "str",
    "emb_codes": "str",
    "emb_codes_tags": "str",
    "energy_100g": "float",
    "alcohol_100g": "float",
}
```

3. Forcer la colonne `code` √† √™tre de type _string_

```{=html}
</details>
</div>
```

<!----- end üî¥,‚ö´ ----->
:::

```{python}
#| classes: yellow-code
#| label: import-openfood-solution
#| eval: false

# Solution pour voie üü°
from utils.preprocess_openfood import download_openfood, import_openfood
download_openfood(destination = "openfood.csv.gz")
openfood = import_openfood("openfood.csv.gz")
openfood.loc[:, ['code', 'product_name', 'energy-kcal_100g', 'nutriscore_grade']].sample(5, random_state = 12345)
```

```{python}
#| label: import-openfood
#| echo: false
#| output: false
#| cache: true
import os
import pandas as pd

from utils.preprocess_openfood import download_openfood, import_openfood
download_openfood(destination = "openfood.csv.gz")
if os.path.exists("openfood.parquet"):
    openfood = pd.read_parquet("openfood.parquet")
else:
    openfood = import_openfood("openfood.csv.gz")
    openfood.to_parquet("openfood.parquet")
```


L'objectif de l'application est de proposer pour un produit donn√© quelques
statistiques descriptives. On propose de se focaliser sur trois 
scores :

- Le [__nutriscore__](https://www.santepubliquefrance.fr/determinants-de-sante/nutrition-et-activite-physique/articles/nutri-score) ;
- Le [__score Nova__](https://fr.openfoodfacts.org/nova) indiquant le degr√© de transformation d'un produit ;
- L'[__√©coscore__](https://docs.score-environnemental.com/), une mesure de l'empreinte carbone d'un produit ;

Ces scores ne sont pas syst√©matiquement disponibles sur `OpenFoodFacts`
mais une part croissante des donn√©es pr√©sente ces informations (directement
renseign√©es ou imput√©es). 

```{python}
indices_synthetiques = ['nutriscore_grade', 'nova_group', 'ecoscore_grade']
```

Le bloc de code ci-dessous propose d'harmoniser le format de ces scores
pour faciliter la repr√©sentation graphique ult√©rieure.

Comme il ne s'agit
pas du coeur du sujet, il est donn√© directement √† tous les parcours. 
Le code source de cette fonction est disponible dans
le module `utils.pipeline`:

```{python}
import pandas as pd
from utils.pipeline import clean_note

indices_synthetiques = ['nutriscore_grade', 'nova_group', 'ecoscore_grade']

openfood.loc[:, indices_synthetiques] = pd.concat(
        [clean_note(openfood, s, "wide") for s in indices_synthetiques],
        axis = 1
    )
```


## 1.3. Classification automatique dans une nomenclature de produits  (üü°,üü¢,üîµ,üî¥,‚ö´)

Pour proposer sur notre application quelques statistiques pertinentes sur
le produit, nous allons associer chaque ligne d'`OpenFoodFacts` 
√† un type de produit dans la `COICOP` pour pouvoir comparer un produit
√† des produits similaires. 

Nous allons ainsi utiliser le nom du produit pour inf√©rer le type de bien
dont il s'agit.

Pour cela, dans les parcours üü°,üü¢ et üîµ, 
nous allons d'utiliser un classifieur exp√©rimental
propos√© sur [`Github InseeFrLab/predicat`](https://github.com/InseeFrLab/predicat)
qui a √©t√© entrain√© sur cette t√¢che sur un grand volume de
donn√©es (non sp√©cifiquement alimentaires). 

Pour les parcours üî¥ et ‚ö´, nous proposons √©galement d'utiliser ce classifieur. 
N√©anmoins, une voie bis est possible pour
entra√Æner soi-m√™me un classifieur en utilisant la cat√©gorisation des donn√©es
disponible directement dans `OpenFoodFacts`. Il est propos√© d'utiliser `Fasttext`
(une librairie sp√©cialis√©e open-source, d√©velopp√©e par `Meta` il y a quelques ann√©es) dans
le cadre de la voie üî¥. Les personnes suivant la voie ‚ö´ sont libres d'utiliser
n'importe quel _framework_ de classification, par exemple un mod√®le disponible
sur [HuggingFace](https://huggingface.co/). 


::: {.cell .markdown}
<!----- boite üü¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üü¢", title = "Nettoyer les donn√©es textuelles (üü¢)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. R√©cup√©rer le dictionnaire de r√®gles dans [ce fichier](https://raw.githubusercontent.com/InseeFrLab/predicat/master/app/utils_ddc.py)
2. Cr√©er une colonne `preprocessed_labels` en appliquant la m√©thode `str.upper` √† la colonne `product_name` afin de la mettre en majuscule
3. Modifier le `DataFrame` avec la syntaxe prenant la forme `data.replace({variable: dict_rules_replacement}, regex=True)`
4. Observer les cas o√π il y a eu des changements, par exemple de la mani√®re suivante

```python
(openfood
    .dropna(subset = ["product_name", "preprocessed_labels"])
    .loc[
        openfood["product_name"].str.upper() != openfood["preprocessed_labels"],
        ["product_name", "preprocessed_labels"]
    ]
)
```

```{=html}
</details>
</div>
```

<!----- end üü¢ ----->
:::


::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Nettoyer les donn√©es textuelles (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. R√©cup√©rer le dictionnaire de r√®gles dans [ce fichier](https://raw.githubusercontent.com/InseeFrLab/predicat/master/app/utils_ddc.py)
2. Cr√©er une colonne `preprocessed_labels` mettant en majuscule la colonne `product_name`
3. Modifier le `DataFrame` avec la syntaxe utilisant la m√©thode `replace` (celle qui s'applique aux `DataFrame`, pas celle s'appliquant √† une `Serie`) et le dictionnaire adapt√©
4. Observer les cas o√π il y a eu des changements,

```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::

::: {.cell .markdown}
<!----- boite üî¥ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üî¥", title = "Nettoyer les donn√©es textuelles (üî¥)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. R√©cup√©rer le dictionnaire de r√®gles dans [ce fichier](https://raw.githubusercontent.com/InseeFrLab/predicat/master/app/utils_ddc.py)
2. Cr√©er une colonne `preprocessed_labels` appliquant les remplacements √† `product_name` gr√¢ce √† la m√©thode `replace` (celle qui s'applique aux `DataFrame`, pas celle s'appliquant √† une `Serie`)
3. Observer les cas o√π il y a eu des changements

```{=html}
</details>
</div>
```

<!----- end üî¥ ----->
:::

::: {.cell .markdown}
<!----- boite ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "‚ö´", title = "Nettoyer les donn√©es textuelles (‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

1. R√©cup√©rer le dictionnaire de r√®gles dans [ce fichier](https://raw.githubusercontent.com/InseeFrLab/predicat/master/app/utils_ddc.py)
2. Cr√©er une colonne `preprocessed_labels` appliquant les remplacements √† `product_name`
3. Observer les cas o√π il y a eu des changements

```{=html}
</details>
</div>
```

<!----- end ‚ö´ ----->
:::


Dans un premier temps, on r√©cup√®re les fonctions permettant d'appliquer sur nos donn√©es 
le m√™me _preprocessing_ que celui qui a √©t√© mis en oeuvre lors de l'entra√Ænement du mod√®le:

```{python}
#| classes: yellow-code
#| label: get-utils-ddc
#| output: false

# Solution pour voie üü° et üü¢
from utils.download_pb import download_pb
download_pb("https://raw.githubusercontent.com/InseeFrLab/predicat/master/app/utils_ddc.py", "utils/utils_ddc.py")
```

Pour observer les nettoyages de champs textuels mis en oeuvre, les lignes suivantes
peuvent √™tre ex√©cut√©es:

```{python}
#| output: false

from utils.utils_ddc import replace_values_ean
replace_values_ean
```

Pour effectuer des remplacements dans des champs textuels, le plus simple est d'utiliser
les expressions r√©guli√®res (`regex`). Vous pouvez trouver une ressource compl√®te
sur le sujet dans [ce cours de `Python` de l'ENSAE](https://pythonds.linogaliana.fr/regex/).

Deux options s'offrent √† nous:

- Utiliser le _package_ `re` et boucler sur les lignes
- Utiliser les fonctionnalit√©s tr√®s pratiques de `Pandas`

Nous privil√©gierons la deuxi√®me approche, plus naturelle quand on utilise des `DataFrames` et
plus efficace puisqu'elle est nativement int√©gr√©e √† `Pandas`. 

La syntaxe prend la forme suivante : 

```python
data.replace({variable: dict_rules_replacement}, regex=True)
```

C'est celle qui est impl√©ment√©e dans la fonction _ad hoc_ du script `utils/preprocess_openfood.py`.
Cette derni√®re s'utilise de la mani√®re suivante:

```{python}
from utils.utils_ddc import replace_values_ean
from utils.preprocess_openfood import clean_column_dataset
openfood = clean_column_dataset(
        openfood, replace_values_ean,
        "product_name", "preprocessed_labels"
)
```

Voici quelques cas o√π notre nettoyage de donn√©es a modifi√© le nom du produit :

```{python}
(openfood
    .dropna(subset = ["product_name", "preprocessed_labels"])
    .loc[
        openfood["product_name"].str.upper() != openfood["preprocessed_labels"],
        ["product_name", "preprocessed_labels"]
    ]
)
```

On peut remarquer que pour aller plus loin et am√©liorer la normalisation des champs,
il serait pertinent d'appliquer un certain nombre de nettoyages suppl√©mentaires, comme
le retrait des mots de liaison (_stop words_). Des exemples de ce type de nettoyages
sont pr√©sents dans le [cours de `Python` de l'ENSAE](https://pythonds.linogaliana.fr/nlpintro/).

Cela est laiss√© comme exercice aux voies üî¥ et ‚ö´.


::: {.cell .markdown}
<!----- boite üî¥,‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Normaliser les champs textuels (üî¥,‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Utiliser `NLTK` ou `SpaCy` (solution pr√©f√©rable) pour ajouter des nettoyages
de champs textuels

```{=html}
</details>
</div>
```

<!----- end üî¥,‚ö´ ----->
:::

On peut maintenant se tourner vers la classification √† proprement parler. 
Pour celle-ci, on propose d'utiliser un mod√®le qui a √©t√© entrain√©
avec la librairie [`Fasttext`](https://fasttext.cc/). Voici comment r√©cup√©rer le mod√®le
et le tester sur un exemple tr√®s basique:

```{python}
from utils.download_pb import download_pb
import os
import fasttext

if os.path.exists("fasttext_coicop.bin") is False:
    download_pb(
        url = config["URL_FASTTEXT_MINIO"],
        fname = "fasttext_coicop.bin"
    )


model = fasttext.load_model("fasttext_coicop.bin")
model.predict("RATATOUILLE")
```

Le r√©sultat est peu intelligible. En effet, cela demande une bonne connaissance de la 
COICOP pour savoir de
mani√®re intuitive que cela correspond √† la cat√©gorie [_"Autres plats cuisin√©s √† base de l√©gumes"_](https://www.insee.fr/fr/statistiques/serie/001764476). 

Avant de g√©n√©raliser le classifieur √† l'ensemble de nos donn√©es, on se propose donc de r√©cup√©rer
les noms des COICOP depuis le site [insee.fr](https://www.insee.fr/fr/metadonnees/coicop2016/division/01?champRecherche=true).
Comme cela ne pr√©sente pas de d√©fi majeur, le code est directement propos√©, quelle que soit la voie emprunt√©e:

```{python}
def import_coicop_labels(url: str) -> pd.DataFrame:
    coicop = pd.read_excel(url, skiprows=1)
    coicop['Code'] = coicop['Code'].str.replace("'", "")
    coicop = coicop.rename({"Libell√©": "category"}, axis = "columns")
    return coicop
    
coicop = import_coicop_labels(
    "https://www.insee.fr/fr/statistiques/fichier/2402696/coicop2016_liste_n5.xls"
)

# Verification de la COICOP rencontr√©e plus haut
coicop.loc[coicop["Code"].str.contains("01.1.7.3.2")]
```

Maintenant nous avons tous les ingr√©dients pour g√©n√©raliser notre approche.
L'application en s√©rie de pr√©dictions
via `Fasttext` √©tant un peu fastidieuse et peu √©l√©gante (elle
n√©cessite d'√™tre √† l'aise avec les listes `Python`) et n'√©tant pas le centre de notre sujet,
la fonction suivante est fournie pour effectuer cette op√©ration :

```{python}
def model_predict_coicop(data, model, product_column: str = "preprocessed_labels", output_column: str = "coicop"):
    predictions = pd.DataFrame(
        {
        output_column: \
            [k[0] for k in model.predict(
                [str(libel) for libel in data[product_column]], k = 1
                )[0]]
        })

    data[output_column] = predictions[output_column].str.replace(r'__label__', '')
    return data

openfood = model_predict_coicop(openfood, model)
```

## 1.3.bis Version alternative via l'API [`predicat`](https://github.com/InseeFrLab/predicat)  (üü°,üü¢,üîµ,üî¥,‚ö´)


L'utilisation d'API pour acc√©der √† des donn√©es devient de plus en plus fr√©quente. 
Si vous √™tes peu familiers avec les API, vous pouvez consulter
ce [chapitre du cours de `Python` de l'ENSAE](https://pythonds.linogaliana.fr/api/)
ou de la documentation [`utilitR` (langage `R`)](https://www.book.utilitr.org/03_fiches_thematiques/fiche_api)

Les API peuvent servir √† faire beaucoup plus que r√©cup√©rer des donn√©es. Elles sont
notamment de plus en plus utilis√©es pour r√©cup√©rer des pr√©dictions
d'un mod√®le. La plateforme [`HuggingFace`](https://huggingface.co/) est tr√®s appr√©ci√©e
pour cela: elle a grandement facilit√© la r√©utilisation de mod√®les mis en disposition
en _open source_. Cette approche a principalement deux avantages:

- Elle permet d'appliquer sur les donn√©es fournies en entr√©e exactement les m√™mes pr√©-traitement
que sur les donn√©es d'entrainement. Ceci renforce la fiabilit√© des pr√©dictions. 
- Elle facilite le travail des _data scientists_ ou statisticiens car ils ne sont plus oblig√©s 
de mettre en place des fonctions compliqu√©es pour passer les pr√©dictions dans une colonne
de `DataFrame`. 

Ici, nous proposons de tester une API mise √† disposition
de mani√®re exp√©rimentale pour faciliter la r√©utilisation de notre mod√®le de classification
dans la nomenclature COICOP.

Cette API s'appelle `predicat` et son code source est
disponible sur [`Github`](https://github.com/InseeFrLab/predicat).

Pour les parcours üü°,üü¢,üîµ, nous sugg√©rons de se cantonner √† tester quelques exemples. 
Pour les parcours üî¥ et ‚ö´ qui voudraient se tester sur les API,
nous proposons de g√©n√©raliser ces appels √† [`predicat`](https://github.com/InseeFrLab/predicat)
pour classifier toutes nos donn√©es. 

::: {.cell .markdown}
<!----- boite üî¥,‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Consommer un mod√®le sous forme d'API (üî¥,‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

Appliquer l'API [`predicat`](https://github.com/InseeFrLab/predicat) en s√©rie pour
cat√©goriser l'ensemble des donn√©es

```{=html}
</details>
</div>
```

<!----- end üî¥,‚ö´ ----->
:::


Voici, pour les parcours üü°,üü¢,üîµ, un exemple d'utilisation:

```{python}
#| eval: false
import requests

def predict_from_api(product_name):
    url_api = f"https://api.lab.sspcloud.fr/predicat/label?k=1&q=%27{product_name}%27"
    output_api_predicat = requests.get(url_api).json()
    coicop_found = output_api_predicat['coicop'][f"'{product_name}'"][0]['label']
    return coicop_found

predict_from_api("Ratatouille")
```

Pour le parcours üîµ, voici un exercice pour tester sur un √©chantillon des donn√©es
de l'`OpenFoodFacts`


::: {.cell .markdown}
<!----- boite üîµ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "üîµ", title = "Consommer un mod√®le sous forme d'API (üîµ)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

A partir des exemples pr√©sents dans [ce _notebook_](https://github.com/InseeFrLab/predicat/blob/master/help/example-request.ipynb),
tester l'API sur une centaine de noms de produits pris al√©atoirement (ceux avant _preprocessing_).


```{=html}
</details>
</div>
```

<!----- end üîµ ----->
:::


## 1.3.ter Entrainer son propre classifieur (üî¥,‚ö´)

Les grimpeurs des voies üî¥ et ‚ö´ sont encourag√©s √† essayer d'entra√Æner
eux-m√™mes un mod√®le de classification.

::: {.cell .markdown}
<!----- boite üî¥, ‚ö´ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
#| eval: true
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Entrainer son propre mod√®le de classification (üî¥, ‚ö´)")
```
<details>
<summary>D√©rouler pour r√©v√©ler les instructions</summary>
```

A partir des exemples pr√©sents dans [ce _notebook_](https://github.com/InseeFrLab/predicat/blob/master/help/example-request.ipynb),
tester l'API sur une centaine de noms de produits pris al√©atoirement (ceux avant _preprocessing_). L'apprentissage peut
√™tre fait √† partir de la variable `category` disponible sur `OpenFoodFacts`.

Voici la consigne: 

- üî¥ : utiliser `fasttext`
- ‚ö´ : libert√© sur le _framework_ utilis√©


```{=html}
</details>
</div>
```

<!----- end üî¥, ‚ö´ ----->
:::



## 1.4. Ecriture de la base sur l'espace de stockage distant

Le fait d'avoir effectu√© en amont ce type d'op√©ration permettra
d'√©conomiser du temps par la suite puisqu'on s'√©vite des calculs √† la
vol√©e co√ªteux en performance (rien de pire qu'une page _web_ qui rame non ?). 

Pour facilement retrouver ces donn√©es, on propose de les √©crire dans un espace
de stockage accessible facilement. Pour cela, nous proposons d'utiliser celui
du `SSP Cloud` pour les personnes ayant un compte dessus. Pour les personnes
n'ayant pas de compte sur le `SSP Cloud`, vous pouvez passer cette √©tape et r√©utiliser
le jeu de donn√©es que nous proposons pour la suite de ce parcours. 

Nous proposons ici d'utiliser le package `s3fs` qui est 
assez pratique pour traiter un espace distant comme on ferait d'un 
espace de stockage local. Pour en apprendre plus sur le syst√®me
de stockage `S3` (la technologie utilis√©e par le SSP Cloud) 
ou sur le format `Parquet`, vous pouvez consulter ce chapitre
du [cours de `Python` de l'ENSAE](https://pythonds.linogaliana.fr/reads3/)

La premi√®re √©tape consiste √† initialiser la connexion (cr√©er un _file system_ 
distant, via `s3fs.S3FileSystem`, qui pointe vers l'espace de stockage du SSP Cloud). 
La deuxi√®me ressemble beaucoup √† l'√©criture d'un fichier en local, il y a seulement une
couche d'abstraction suppl√©mentaire avec `fs.open`: 


```{python}
from utils.import_yaml import import_yaml
import s3fs

config = import_yaml("config.yaml")
DESTINATION_OPENFOOD = f"{config['BUCKET']}{config['DESTINATION_DATA_S3']}/openfood.parquet"

# Initialisation de la connexion
fs = s3fs.S3FileSystem(
    client_kwargs={"endpoint_url": config["ENDPOINT_S3"]}
)

# Ecriture au format parquet sur l'espace de stockage distant
with fs.open(DESTINATION_OPENFOOD, "wb") as file_location:
    openfood.to_parquet(file_location)
```

‚ö†Ô∏è __Il faut avoir modifi√© la valeur de `BUCKET` dans le fichier `config.yaml` pour
que cette commande fonctionne__. 

Enfin, pour rendre ce fichier accessible √† votre future application, 
il est n√©cessaire d'√©diter la cellule ci-dessous pour remplacer
`<USERNAME_SSPCLOUD>` par votre nom d'utilisateur sur le `SSPCloud` puis 
d'ex√©cuter la cellule suivante: 

```{python}
#| eval: false
!mc anonymous set download s3/<USERNAME_SSPCLOUD>/2023/sujet4/diffusion
```

qui rend ce fichier public. 

Le fichier sera ainsi disponible en t√©l√©chargement directement depuis un URL de la forme: 

> https://minio.lab.sspcloud.fr/<USERNAME_SSPCLOUD>/2023/sujet4/diffusion/openfood.parquet
