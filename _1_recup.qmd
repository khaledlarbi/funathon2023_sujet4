##Â 1. RÃ©cupÃ©ration et nettoyage de la base `OpenFoodFacts`

### PrÃ©liminaire (ğŸŸ¡,ğŸŸ¢,ğŸ”µ,ğŸ”´,âš«)

Comme nous allons utiliser frÃ©quemment certains paramÃ¨tres,
une bonne pratique consiste Ã  les stocker dans un fichier
dÃ©diÃ©, au format `YAML` et d'importer celui-ci via
`Python`. Ceci est expliquÃ© dans [ce cours de l'ENSAE](https://ensae-reproductibilite.github.io/website/chapters/application.html#etape-3-gestion-des-param%C3%A8tres)

Nous proposons de crÃ©er le fichier suivant au nom `config.yaml`:

```yaml
URL_OPENFOOD: "https://static.openfoodfacts.org/data/en.openfoodfacts.org.products.csv.gz"
ENDPOINT_S3: "https://minio.lab.sspcloud.fr"
BUCKET: "projet-funathon" # <- âš ï¸ Ligne Ã  changer
DESTINATION_DATA_S3: "/2023/sujet4/diffusion"
```

âš ï¸ Si vous dÃ©sirez pouvoir reproduire tous les exemples de ce fichier, vous devez
changer la variable `BUCKET` pour mettre votre nom d'utilisateur sur le `SSPCloud`.

Nous allons lire ce fichier avec le package adaptÃ© pour transformer ces
instructions en variables `Python` (stockÃ©es dans un dictionnaire)



::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "Utiliser un fichier YAML (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

A partir des exemples prÃ©sents dans [cette page](https://stackoverflow.com/questions/1773805/how-can-i-parse-a-yaml-file-in-python),
importer les variables dans un objet `Python` nommÃ© `config`

```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸ”µ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "Utiliser un fichier YAML (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

Utiliser le package `PyYAML` pour importer les Ã©lÃ©ments prÃ©sents dans `config.yaml` dans un objet `Python` nommÃ© `config`

```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸ”´,âš« ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”´", title = "Utiliser un fichier YAML (ğŸ”´,âš«)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

Importer les Ã©lÃ©ments prÃ©sents dans `config.yaml` dans un objet `Python` nommÃ© `config`

```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::



```{python}
#| classes: yellow-code

#Â Solution pour voie ğŸŸ¡
import yaml

def import_yaml(filename: str) -> dict:
    """
    Importer un fichier YAML

    Args:
        filename (str): Emplacement du fichier

    Returns:
        dict: Le fichier YAML sous forme de dictionnaire Python
    """
    with open(filename, "r", encoding="utf-8") as stream:
        config = yaml.safe_load(stream)
        return config

import_yaml("config.yaml")
```

Il est recommandÃ© pour la suite de
copier-coller la fonction crÃ©Ã©e (ne pas oublier les imports associÃ©s) 
dans un fichier Ã  l'emplacement `utils/import_yaml.py`. Cette approche modulaire est
une bonne
pratique, recommandÃ©e
dans [ce cours de l'ENSAE](https://ensae-reproductibilite.github.io/website/).

Pour la voie ğŸŸ¡, ce fichier a dÃ©jÃ  Ã©tÃ© crÃ©Ã© pour vous. 
Le tester de la maniÃ¨re suivante:

```{python}
#| classes: yellow-code

#Â Solution pour voie ğŸŸ¡
from utils.import_yaml import import_yaml
config = import_yaml("config.yaml")
```


### TÃ©lÃ©charger et nettoyer la base `OpenFoodFacts` (ğŸŸ¡,ğŸŸ¢,ğŸ”µ,ğŸ”´,âš«)

Un export quotidien de la
base de donnÃ©es `OpenFoodFacts` est fourni au format `CSV`. L'URL est le suivant:

```{python}
config["URL_OPENFOOD"]
```

Il est possible d'importer de plusieurs maniÃ¨res ce type de fichier avec `Python`. 
Ce qu'on propose ici, 
c'est de le faire en deux temps, afin d'avoir un contrÃ´le des 
options mises en oeuvre lors de l'import (notamment le format de certaines variables) :

- Utiliser `requests` pour tÃ©lÃ©charger le fichier et l'Ã©crire, de maniÃ¨re intermÃ©diaire, 
sur le disque local ;
- Utiliser `pandas` avec quelques options pour importer le fichier puis le manipuler. 


::: {.cell .markdown}
<!----- boite ğŸŸ¢ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸŸ¢", title = "TÃ©lÃ©charger et importer OpenFoodFacts (ğŸŸ¢)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

1. Utiliser la fonction `requests.get` pour tÃ©lÃ©charger le fichier.
Vous pouvez vous inspirer de rÃ©ponses [ici](https://stackoverflow.com/questions/16694907/download-large-file-in-python-with-requests)


2. Utiliser `pd.read_csv` avec les options suivantes:
        + Le fichier utilise `\t` comme tabulation
        + Utiliser l'argument `parse_dates=["created_datetime", "last_modified_datetime", "last_image_datetime"]`
        + Il est nÃ©cessaire de figer quelques types avec l'argument `dtype`. Voici le dictionnaire Ã  passer
        
```python
{
    "code ": "str",
    "emb_codes": "str",
    "emb_codes_tags": "str",
    "energy_100g": "float",
    "alcohol_100g": "float",
}
```

3. Forcer la colonne `code` Ã  Ãªtre de type _string_ avec la mÃ©thode `.astype(str)`

```{=html}
</details>
</div>
```

<!----- end ğŸŸ¢ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸ”µ ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "ğŸ”µ", title = "TÃ©lÃ©charger et importer OpenFoodFacts (ğŸ”µ)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

1. Utiliser le _package_ `requests` pour tÃ©lÃ©charger le fichier. Si vous voulez afficher une barre de progression,
vous pouvez vous inspirer de la fonction `download_pb` du package [`cartiflette`](https://github.com/InseeFrLab/cartiflette)

2. Lire les donnÃ©es avec `pandas` avec les options suivantes:
        + Le fichier utilise `\t` comme tabulation
        + Utiliser l'argument `parse_dates = ["created_datetime", "last_modified_datetime", "last_image_datetime"]`
        + Il est nÃ©cessaire de figer, voici le dictionnaire Ã  passer
        
```python
{
    "code ": "str",
    "emb_codes": "str",
    "emb_codes_tags": "str",
    "energy_100g": "float",
    "alcohol_100g": "float",
}
```

3. Forcer la colonne `code` Ã  Ãªtre de type _string_

```{=html}
</details>
</div>
```

<!----- end ğŸ”µ ----->
:::

::: {.cell .markdown}
<!----- boite ğŸ”´,âš« ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "TÃ©lÃ©charger et importer OpenFoodFacts (ğŸ”´,âš«)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

1. TÃ©lÃ©charger le fichier avec `Python`. Pour s'assurer de la progression du tÃ©lÃ©chargement, 
utiliser Ã©galement la librairie `tqdm`.

2. Lire les donnÃ©es avec `pandas` avec les options suivantes:
        + Le fichier utilise `\t` comme tabulation
        + Utiliser l'argument `parse_dates = ["created_datetime", "last_modified_datetime", "last_image_datetime"]`
        + Il est nÃ©cessaire de figer, voici le dictionnaire Ã  passer
        
```python
{
    "code ": "str",
    "emb_codes": "str",
    "emb_codes_tags": "str",
    "energy_100g": "float",
    "alcohol_100g": "float",
}
```

3. Forcer la colonne `code` Ã  Ãªtre de type _string_

```{=html}
</details>
</div>
```

<!----- end ğŸ”´,âš« ----->
:::

```{python}
#| classes: yellow-code
#| label: import-openfood-solution
#| eval: false

# Solution pour voie ğŸŸ¡
from utils.preprocess_openfood import download_openfood, import_openfood
download_openfood(destination = "openfood.csv.gz")
openfood = import_openfood("openfood.csv.gz")
openfood.loc[:, ['code', 'product_name', 'energy-kcal_100g', 'nutriscore_grade']].sample(5, random_state = 12345)
```

```{python}
#| label: import-openfood
#| echo: false
#| output: false
#| cache: true
from utils.preprocess_openfood import download_openfood, import_openfood
openfood = import_openfood("openfood.csv.gz")
```

```{python}
#| echo: false
#| output: true
openfood.loc[:, ['code', 'product_name', 'energy-kcal_100g', 'nutriscore_grade']].sample(5, random_state = 12345)
```

### Classification automatique dans une nomenclature de produits  (ğŸŸ¡,ğŸŸ¢,ğŸ”µ,ğŸ”´,âš«)

Pour proposer sur notre application quelques statistiques pertinentes sur
le produit, nous allons associer chaque ligne d'`OpenFoodFacts` 
Ã  un type de produit dans la `COICOP` pour pouvoir comparer un produit
Ã  des produits similaires. 

Nous allons ainsi utiliser le nom du produit pour infÃ©rer le type de bien
dont il s'agit. Pour cela, dans les parcours ğŸŸ¡,ğŸŸ¢ et ğŸ”µ, 
nous allons d'utiliser un classifieur expÃ©rimental
proposÃ© sur [`Github InseeFrLab/predicat`](https://github.com/InseeFrLab/predicat)
qui a Ã©tÃ© entrainÃ© sur cette tÃ¢che sur un grand volume de
donnÃ©es (non spÃ©cifiquement alimentaires). Pour les parcours ğŸ”´ et âš«, nous 
proposons d'entraÃ®ner un classifieur en utilisant la catÃ©gorisation des donnÃ©es
disponible directement dans `OpenFoodFacts`. Il est proposÃ© d'utiliser `Fasttext`
(une librairie spÃ©cialisÃ©e open-source, dÃ©veloppÃ©e par `Meta` il y a quelques annÃ©es) dans
le cadre de la voie ğŸ”´. Les personnes suivant la voie âš« sont libres d'utiliser
n'importe quel _framework_ de classification. 


Dans un premier temps, on rÃ©cupÃ¨re les fonctions permettant d'appliquer sur nos donnÃ©es 
le mÃªme _preprocessing_ que celui qui a Ã©tÃ© mis en oeuvre lors de l'entraÃ®nement du modÃ¨le:

```{python}
#| classes: yellow-code
#| label: get-utils-ddc
#| output: false

# Solution pour voie ğŸŸ¡ et ğŸŸ¢
from utils.download_pb import download_pb
download_pb("https://raw.githubusercontent.com/InseeFrLab/predicat/master/app/utils_ddc.py", "utils/utils_ddc.py")
```

Pour observer les nettoyages de champs textuels mis en oeuvre, les lignes suivantes
peuvent Ãªtre exÃ©cutÃ©es:

```{python}
#| output: false

from utils.utils_ddc import replace_values_ean
replace_values_ean
```

Pour effectuer des remplacements dans des champs textuels, le plus simple est d'utiliser
les expressions rÃ©guliÃ¨res (`regex`). Vous pouvez trouver une ressource complÃ¨te
sur le sujet dans [ce cours de `Python` de l'ENSAE](https://pythonds.linogaliana.fr/regex/).

Deux options s'offrent Ã  nous:

- Utiliser le _package_ `re` et boucler sur les lignes
- Utiliser les fonctionnalitÃ©s trÃ¨s pratiques de `Pandas`

Nous privilÃ©gierons la deuxiÃ¨me approche, plus naturelle quand on utilise des `DataFrames` et
plus efficace puisqu'elle est nativement intÃ©grÃ©e Ã  `Pandas`. 

La syntaxe prend la forme suivante : 

```python
data.replace({variable: dict_rules_replacement}, regex=True)
```

C'est celle qui est implÃ©mentÃ©e dans la fonction _ad hoc_ du script `utils/preprocess_openfood.py`.
Cette derniÃ¨re s'utilise de la maniÃ¨re suivante:

```{python}
from utils.utils_ddc import replace_values_ean
from utils.preprocess_openfood import clean_column_dataset
openfood = clean_column_dataset(openfood,replace_values_ean, "product_name", "preprocessed_labels")
```

Voici quelques cas oÃ¹ notre nettoyage de donnÃ©es a Ã©tÃ© efficace:

```{python}
openfood.loc[:, ["product_name", "preprocessed_labels"]].dropna().loc[openfood["product_name"].str.upper() != toto["preprocessed_labels"]]
```

On peut remarquer que pour aller plus loin et amÃ©liorer la normalisation des champs,
il serait pertinent d'appliquer un certain nombre de nettoyages supplÃ©mentaires, comme
le retrait des mots de liaison (_stop words_). Des exemples de ce type de nettoyages
sont prÃ©sents dans le [cours de `Python` de l'ENSAE](https://pythonds.linogaliana.fr/nlpintro/).
Cela est laissÃ© comme exercice aux voies ğŸ”´ et âš«


::: {.cell .markdown}
<!----- boite ğŸ”´,âš« ----->

```{=html}
```{python}
#| echo: false
#| output: asis
from utils_notebook import create_box_level
create_box_level(color = "grey", title = "Normaliser les champs textuels (ğŸ”´,âš«)")
```
<details>
<summary>DÃ©rouler pour rÃ©vÃ©ler les instructions</summary>
```

Utiliser `nltk` ou `SpaCy` (solution prÃ©fÃ©rable) pour ajouter des nettoyages
de champs textuels

```{=html}
</details>
</div>
```

<!----- end ğŸ”´,âš« ----->
:::